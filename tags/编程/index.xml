<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on 火山灰</title>
    <link>https://sanbeichahegongheguo.github.io/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on 火山灰</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Dec 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://sanbeichahegongheguo.github.io/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>正常人学编程 前言</title>
      <link>https://sanbeichahegongheguo.github.io/1%E6%AD%A3%E5%B8%B8%E4%BA%BA%E5%AD%A6%E7%BC%96%E7%A8%8B-%E5%89%8D%E8%A8%80/</link>
      <pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/1%E6%AD%A3%E5%B8%B8%E4%BA%BA%E5%AD%A6%E7%BC%96%E7%A8%8B-%E5%89%8D%E8%A8%80/</guid>
      <description>现有的编程课程，书本，教程，对非计算机专业、转行的初学者而言，都非常糟糕。
 抽象得太抽象浓缩，看完无法迁移。伪代码无法实现转化为实际代码。 具体的手册太具体，一大堆功能、函数、方法交给你。为了教会你，用的都是彼此分离不同属没有关联的例子。只是为了讲这个方法的用法而用，实际使用的时候依然用不好。只有正确的用法，不指出常见的错误方法。典型的就是 Python 著名的库 Pandas 的作者写的《Python数据分析》、《鸟叔的Linux私房菜》。很多编程入门书，真的就只是入门书。对于有计算机编程基础的人员，入了门，很快就可以开始做项目。但是对于从零开始的人员，则需要经过痛苦的摸索阶段。 另外一些书则是介绍一些奇淫巧技，对于初学者毫无帮助。 还有的书因为出版的缘故，写得极其精简简略，生怕多重复强调一点。实际上，就像复习是最好的学习，而不断的重复也是让初学者更好入门的招数。不要怕啰嗦，只要能把道理讲清楚，特别是对于网络发布的情况。反而应该反对过度的凝练。传统的教育方法是书本凝练，课堂详细展开。但是对于自学、转行的人员，无法达到这样的条件。 还有就是对于零基础的人员，缺乏足够的知识组合。其实学习本身应该是融会贯通的，就像在学校，不会一学期就学这一门，学完这门才学另一门，都是同步进行。而如果课程设置合理，完全可以刚在这门课学到的知识，就用在了下一门的基础上。形成良好的闭环和循环增强，巩固了旧知识，学会了新知识。 刷LeetCode怎么刷？这块其实也是一个痛点。我最开始刷LeetCode的时候，想得最多的就是，我写的这个解法，它是怎么在后台被测试的？如何更好的构建类？而一直没有一个合格的人告诉我是如何运作的，似乎所有的人都默认为大家都知道了。QTMD。 也就是说，目前存在一个 huge 的 gap 横亘在初入门和熟练资深者之间，导致初学者长期卡在初学者阶段，无法良好的进入下一阶层。这个问题需要改变。这也是我们目前现代化教育的弊端：  学生学不会。 学生学会了不会用。 学生用了但是不是应该的用法。   我们的教育也是出大问题了。
现在市面上有不少号称针对初学者的教程，比如：《一百天学会python》《零基础入门Linux》，但实际上一点都不实用。要么是太简略，该教的必备知识没教，要么是太简陋，只不过是把官方文档堆了出来，要么就是太庞杂，一坨东西呼人脸上，无所适从。
所以我想，自己试着一点点，把基础知识和引用知识，捣碎了，结合具体事例，反复灌输，传授出来。
太基础的我也不讲，因为网上已经有很多很好的。
我的大纲设计是：
 这个知识点，到底是什么，是来解决什么问题的。 这个知识点，在python下是怎么做，在Perl、Java、kotlin、Go、C/C++ 下又分别是怎么做。 配合实例，怎么把这个知识用起来。  希望能够成功。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>正常人学编程 前言</title>
      <link>https://sanbeichahegongheguo.github.io/linux-%E7%B3%BB%E7%BB%9F%E5%92%8C-shell-%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E5%BD%95/</link>
      <pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/linux-%E7%B3%BB%E7%BB%9F%E5%92%8C-shell-%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E5%BD%95/</guid>
      <description>本文来源：知乎专栏
简答题 1. 计算机硬件和软件的关系是什么？ 硬件是计算机系统的物理组成部分，即计算机系统中的各种物理装置，包括控制器、运算器、内存储器、I/O设备（如硬盘、键盘）以及外存储器等。它是计算机系统的物质基础。
软件系统就是所有程序、数据和相关文件的集合。从狭义的角度上讲，软件是指计算机运行所需的各种程序。没有硬件，谈不上应用计算机。但是，光有硬件而没有软件，计算机也不能工作。（1）硬件和软件互相依存；（2）硬件和软件无严格界线；（3）硬件和软件协同发展。
计算机软件和硬件密不可分，协调工作。软件的运行通过硬件呈现给用户，用户通过硬件进行开发及修改软件，二者相互依存，缺一不可。离开了硬件的软件什么也做不了，离开软件的硬件也只是摆设。对于计算机而言，软件像是灵魂，硬件像是肉体。二者相互依存。同时二者也相互制约。在计算机的早期，硬件很薄弱，限制了计算机的发展；如今，硬件配置很多都很高了，软件的优化对提高计算机的性能十分关键。以手机为例，早期的智能机内存通常只有512MB，提高手机内存是解决手机卡顿的关键因素，而如今，很多手机的内存已达10GB甚至12GB，超过了很多电脑的内存，但是很多时候仍然卡顿，一个重要的原因是软件优化不够好（很多程序设计者在面对大内存时，以不将内存优化作为程序设计的重点，于是出现了你有多少硬件资源，我软件就要占用多少硬件资源），占用了大量的硬件资源。
综上，硬件和软件是计算机重要组成部分，缺一不可。计算机性能的提升即依赖于硬件配置的提高，也依赖于软件水平的优化。
参考资料：
 https://www.sophia.org/tutorials/the-relationship-between-hardware-and-software https://www.quora.com/What-is-the-relation-between-hardware-and-software-2  2. 常见的 Linux 发行版本有哪些？它们的主要差别在什么地方？ Linux 发行版本是基于Linux内核和软件包管理系统创建的操作系统。通常一个 Linux 发行版包括 Linux 内核、GNU 工具和库、其他一些软件以及窗口系统、窗口管理器和桌面环境。 迄今为止，已经有超过 600 多个 Linux 发行版本，其中将近 500 个仍处于活跃开发状态。其中最常用的一些商业支持发行版有：Fedora(Red Hat), openSUSE(SUSE) 和 Ubuntu，社区驱动的发行版有：Debian, Slackware, Gentoo和 Arch Linux。 值得一提的是 Android 系统，我们知道 Android 也是基于 Linux 的，但是它算不算一个 Linux 发行版本呢？很多大佬有不同的意见，有人认为 Android 也是一种发行版，有人指出 Android 缺少包括 glibc 在内的很多 GUN 工具，因而不能算是一种 Linux 发行版。
Linux 发行版 = Linux 内核 + 商业软件
常见的 Linux 发行版：
 国外：RedHat、Fedora、Centos、SUSE、Debian、Ubuntu、Mint、Arch、Manjaro 国内：红旗、Deepin  是不是一千个用户就有一千个 Linux 系统推荐理由？</description>
    </item>
    
    <item>
      <title>section01-环境配置-01</title>
      <link>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-01/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-01/</guid>
      <description>环境配置分两种，一种是语言本身的环境配置，一种是编写代码时所需要的编辑器。
1 先讲讲我们要讲的语言。 在这之前再讲语言的类型。
1.1 语言分机器语言，汇编语言，和高级语言。 机器语言，也即低级语言，就是CPU能够认识的语言，也就是二进制指令。如果让你写一段程序计算1+1，那就需要些大量的 1和0，显然正常人都没办法做到。这块以后如果有兴趣可以讲讲普通人如何用二进制编程，其实是挺有意思。类似摩尔电码一样，用1和0代表一系列运算。具象化的那就是《三体》里的人列计算机，仅仅通过1和0，构建出与门或门非门与非门等等，再在这个基础上进行逻辑运算。和目前的深度学习理念非常像。如果以后我会讲到深度学习，那就会先讲这个。
先列几个机器语言：
指令部份的示例: 0000 代表 加载（LOAD） 0001 代表 存储（STORE） ... 暂存器部份的示例: 0000 代表暂存器 A 0001 代表暂存器 B ... 存储器部份的示例: 000000000000 代表地址为 0 的存储器 000000000001 代表地址为 1 的存储器 000000010000 代表地址为 16 的存储器 100000000000 代表地址为 2^11 的存储器 集成示例: 0000,0000,000000010000 代表 LOAD A, 16 0000,0001,000000000001 代表 LOAD B, 1 0001,0001,000000010000 代表 STORE B, 16 0001,0001,000000000001 代表 STORE B, 1 ...  是不是基本上就不是给人看的。
低级语言，也称符号语言，就是在机器语言上改造出来的至少可以让人一眼看懂的语言，就是把操作性的指令，从0和1改造成约定俗成的英文字符，而且一般都是有英文原意的英文单词或缩写。比如把寄存器BX的内容送到AX中，用机器语言和汇编语言写就分别是：
1000100111011000 机器指令 mov ax,bx 汇编指令  区别还是挺明显。后者至少大概知道是啥意思。</description>
    </item>
    
    <item>
      <title>section01-环境配置-02-语言环境</title>
      <link>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-02/</link>
      <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-02/</guid>
      <description>1、优先推荐初学者先使用网上环境，而不是本地部署。 1、Cloud Studio Cloud Studio 是基于浏览器的集成式开发环境，是腾讯公司的，支持绝大部分编程语言，包括 HTML5、PHP、Python、Java、Ruby、C/C++、.NET 等等，无需下载安装程序，一键切换开发环境。 Cloud Studio 提供了完整的 Linux 环境，并且支持自定义域名指向，动态计算资源调整，可以完成各种应用的开发编译与部署。
2、实验楼 实验楼也提供网络在线的开发环境，不过非付费用户没办法保存。但是对于初入Linux的朋友，可以在上面尝试性操作，也算一个便利。
3、Google家的在线平台 这个需要翻墙，仅供参考。
2、本地编辑器 最开始入门，各类语言首先要学会如何在终端下运行，因为以后如果真的到了工业应用级别，服务器都是只提供命令行模式的。所以终端下命令，以及vim或者Emrac的使用最好能会一些。
然后就是在一些文本编辑器下使用。常见的有sublime text2or3、nodepad++、Atom、Visual Studio Code等等。
这类文本编辑器的特点就是轻量级,，不直接提供编程环境，可以自行改造成适应不同语言的编程环境。我自己使用过多款后最后选用的还是sublime text3。最够快捷和轻量级，没有VScode、Atom那么花哨。不过后两者也是很出色的，只是对于目前的我有些花哨了。
最后就是终极的IDE，集成开发环境。就是把它一装，你需要的编辑器+语言环境，都安排好了。这里的典型就是微软家的visual studio和苹果家的Xcode。装了这两个，基本上就等于装了编辑器+C/C++语言环境，如果再想装什么语言，通过内置的环境配置也可以搞定。另外还有一些语言专属的IDE。我们下面一个一个说。
首先是命令行下运行语言，这块后面肯定会一一讲到。
然后讲一下我接触到的各类文本编辑器的优劣。
首先肯定是vim和emrac。这两款文本编辑器是适用于终端界面环境下。早期编程没有图形界面，那时候的程序员写代码很麻烦的。于是就有两个程序员分别开发了各自认为合适的文本编辑器。
vi
vim是在vi基础上的增强版，Linux系统下已经默认输入vi就等于vim。所以我也没用过原版vi。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>section02-计算机起源与组成</title>
      <link>https://sanbeichahegongheguo.github.io/section02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</link>
      <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</guid>
      <description>本文转自[零基础编程入门（02）——计算机起源与组成]
附该作者的版权说明
 三、关于本教程版权 本教程系列没有出版计划，以后也不会有，内容将直接公布在网上，但严禁第三方将其修订商业使用，转载不用向我询问，但必须在头部或尾部标明鄙人的知乎原文地址，鄙人并不希望有人借本教程牟利，知识永远都不应当收费，当然如果有人看完本教程觉得很有帮助自愿想给我午餐加个鸡腿，我也不反对，先行谢了。
 作者：HalfmanG2
链接：https://zhuanlan.zhihu.com/p/36534718
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
一、计算机的起源与历史 说到计算机的起源，首先从字面上就可以了解到计算机就是用于计算的机器的意思，事实上最早的计算机也的确就是一台用于计算的机器，早在史前社会，人类就已经发明了计算机，它是长这样的：
图1，上古人力二则运算计算机
同学们看了肯定很惊诧，哎哟我去，这不就是几根破绳子嘛，和能操红警打星际（嗯，没暴露年龄吧？）的计算机有什么关系，你不是在忽悠我吧？
那鄙人得说，就这几根破绳子还真是一台计算机，原始人使用这种称为结绳记事的方式来记录日常生活中的一些数据，比如，鄙人今天下海捞了3条鱼，那么我就在一根绳子上打3个结，记住我捞了3条鱼，然后我吃了一条，就解开一个结变成2个结，如果到了月底发现框里的鱼和绳子上的结对不上，那鱼肯定就是被我老婆偷吃了，晚上回去好好教育教育&amp;hellip;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
从这个故事种我们可以看到，这几根破绳子有如下几个作用：
 可以用于记录数字，1个结就代表数字1，2个结就代表数字2，以此类推 可以进行加减运算，比如我绳子上有2个结，然后今天又捞了3条，那么就再打3个结，变成了5个结，那么就是2+3=5。然后晚上我吃了1条，于是就解开1个结，变成4个结，那么就是5-1=4。  有了这两个个作用，我们就得到了一台完整二则运算计算机，因为一台计算机只需要有两个功能：
 记录数据，将需要参与运算的数字记录下来 对数据进行运算，对记录下来的数字进行运算  但是由于只能用于加减运算，所以就称为二则运算计算机。
但是显然，这种计算机运行效率那是相当的低下，记录的数据也非常有限，比如我昨天捞了200条鱼，那我就得打200个结，绳子是不是够长不说，就是打结的功夫也是相当的累人，指不定比捞鱼还慢，而且还只能做加减运算，比如如果我和隔壁张三做大额鱼类期货交易，要做乘除法怎么办？200条鱼的绳子乘个2就是400条，那我得再打上200个结，乘个10就是2000个结，我去，这活没法干了。
所以，讲到这里鄙人不得不佩服我们古人的智慧，公元3世纪（200多年）的时候，东汉人徐岳发明了这玩意儿：
图2，国产人力四则运算计算机
没错，就是算盘，不过很可惜，由于鄙人小学珠算没及格，这东西咋用的我早丢给爷爷辈了，但是！鄙人可以告诉你，算盘相对于绳子，有两大改良：
 算盘加入了进位  我们可以看到算这个盘每一列有上面2个珠子和下面5个珠子，下面5个珠子每向上推1个代表加个1，而上面的珠子每推1个代表加5，上面2个珠子都推了就代表加10，这就是个典型的10进位，但是由于算盘有很多种，有些是上面1珠下面4珠的，所以并不能说所有算盘都是10进位，事实上更多的是混合进位，恩，说远了，不懂没关系。
当然，你现在还不知道什么是进位，鄙人后面会再给大家详细解释，不明白的同学稍安勿躁，接着看下去。
 算盘加入了乘除法  算盘可以通过一定的口诀，实现乘除法，所谓口诀就是一些预先设计好的操作顺序。比如第1步推这个，第2步推哪个等等，然后操作人员只需要根据口诀去一步步操作，就能对算盘上当前的数据进行乘除法。
当然，真正的珠算口诀要复杂的多，具体我就不说了，因为我自己也搞不清，没做过账房先生。看到这想知道的同学鄙人也不推荐你去研究，因为和我们要学的东西无关，无关的东西就不要学，这是学习的根本方法之一，有的时候我们需要克制下自己的求知欲。
回到正题，从上面我们知道，算盘可以通过这些预先设计好的操作顺序对算盘上记录的数据进行乘除法，非常有意思的是，这些口诀，从本质上来讲，就是一种程序，因为程序本质上就是进行某种运算的操作顺序，而设计了这些口诀的古人则正是我们中国最早的程序员。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
看到这里，我们同学是不是很震撼，感到特别震惊？所以说我们古中华文明的智慧是无穷无尽的，我们现代生活中的很多东西早就已经存在于中国古代，所以同学们切勿自怨自艾，国人当对身为中华人有信心，为身为中华文明的传人而自豪。同时也要为我们将要学习的内容放松心态，古人都能发明的东西，你怎么会有学不会的道理？
上面我们学到了中华文明的璀璨之后，接下来，我们把时间向后拨上1600多年，来到近现代的欧洲。
1941年，二战正进行得如火如荼，德军依靠优势空军力量，不断对英国进行空袭，大量的城镇在一夜间满目疮痍。英军为了获得对德国空军的战术与情报优势，瞄上了德国了的用于电报加密的恩尼格玛密码机（Enigma Machine）。
恩尼格玛密码机大致上就是好几个转盘，当发报员通过旋钮对机器进行日期设置后，每敲入一个字符，比如A，然后转盘就会通过一定的机械运动，将其转换为另一个字符，比如R，然后运转规律会按日期有所变化，比如今天按A，输出的是R，明天按A，输出就变成C了。然后收报员在收到加密的电报后，输入相同的日期，然后就能解密，然后得到正确的电报内容。当然实际的加密过程要复杂的多，因为还有变码等等功能，这个我们就不关心了，你就先这么理解吧。
通过这个机器，德军能很好的防止英军截获军事情报，所以，英军为了破解恩尼格玛密码机，便从全国征招各路英豪，齐聚一个叫布莱切利的小庄园，其中就有我们的人工智能之父，提出了图灵机的阿伦·图灵，还有全国的顶尖数学家和顶尖电器工程师。
然后某一天，由于一个德国发报员的发送的报文有一个拼写错误，抱着严谨的心态没换密码又重发了一遍正确的报文，英军意外通过对两份密文对比找到了恩尼格玛的部分规律，然后在天才们的努力下，最终完整破译了密码机的运行规律。
但是，我们故事到这里还没有完，虽然已经找到了密码机的运行规律，但是由于每破译一份电报都要进行巨量的数学计算，即使有一群数学大咖协作，每一份电报破译完几乎已经是一个星期后的事情了，对瞬息万变的战局几乎起不到任何作用。
于是在阿伦·图灵的主导下，电器工程师赫斯·罗宾逊与汤米·佛洛亚斯发明建造了一台电器设备，名为克罗索斯，差不多长这样：
图3，克罗索斯电器计算机
这台设备由电力马达驱动，其中用于记录密文运算的电路模块是可以替换的，以实现变换解密算法，当操作员通过打字机完成需要需要计算的电报密文输入后，这台设备便会开始根据记录了算法的电路模块对电报进行解密，每秒大约能解密5000字。
这样的运行效率显然已经完全满足了英军需要，一份德军密电几分钟后就能放到丘吉尔桌上，而克罗索斯则因为汤米·佛洛亚斯设计的独特的可替换算法电路模块，而成为了世界上第一台可编程电子计算机。
然而非常可惜的是，由于英军出于机密的考虑（恩尼格玛破译有很多黑历史就不说了，比如故意放任已经破译的密电，而让多佛惨遭轰炸），克罗索斯长期被列为高级机密，隐藏在了机密文档之中，而其计算机本身也在二战后惨遭销毁。
至于阿伦·图灵更是在二战后因其他原因被迫自杀，成为计算机界知名的惨案，至此，这段历史也就再也无人知晓，直到近十几年才得以曝光。但是此时，世界第一台电子计算机的桂冠却早已被美国1946年制造的用于原子弹制造研究计算的ENIAC埃尼阿克计算机摘去，而他的设计者之一，冯·诺依曼更是依靠其对ENIAC埃尼阿克计算机设计方案的优化，一举成为现代计算机之父。
（后注，克罗索斯破解的实质上是德军在恩尼格玛上衍生的更为复杂的Tunny密码机，但限于篇幅就混为一谈吧，事实上这也是需要克罗索斯需要能替换算法的主要原因）
二、现代计算机起源 1944年，美籍匈牙利数学家与量子物理学家，冯·诺依曼正在美国洛·斯阿拉莫斯实验室参与一件苦逼的工作，原子弹研发。由于原子弹研发过程中大量需要进行几十亿次的巨量的数学运算，他不得不雇佣了上百个妹子为其做算术题，然而依然完全不够，无尽的数学题如同海绵一般吸干了他那无穷无尽的脑细胞。
一个偶然的机会，他遇到了ENIAC埃尼阿克计算机研发部门的主管，在了解了其工作后，立刻产生了极大的兴趣，然后在主管推荐下，便以顾问的身份加入了ENIAC部门。
当时的埃尼阿克ENIAC计算机设计方案中并没有数据存储功能，其操作方式极为原始，需要由妹子（不对，操作人员）通过电线插座面板（简称控制面板，是不是很熟悉）去进行输入操作，然后再进行计算和输出结果，其输入数据操作时间往往比计算时间还长，加起来的运算效率可能还不如我们的算盘。
冯·诺依曼加入顾问团后，便开始着手对其工作方式进行改良，最终在1945年，写了一份101页的报告，提出了一个名为『EDVAC』翻译过来就是『存储程序通用电子计算机方案』的新型可编程电子计算机方案，而这个方案正是如今世界上所有计算机的根基，70年了，依然未被推翻，所以如今所有的计算机也被称为冯·诺依曼计算机，而其本人也被称为现代计算机之父而享誉全球。
在这份报告中，有三个关键点：
第一、计算机中的数据应当使用二进制进行存储与运算
第二、程序也是数据，应当与数据一同存储在计算机的存储器中
第三、计算机应当由五个部分组成，分别为：运算器、控制器、存储器、输入设备、输出设备
这三点非常重要，下面我们就一个一个来看。
第一点，计算机中的数据应当使用二进制进行存储与运算</description>
    </item>
    
    <item>
      <title>section01-环境配置-03-编辑器设置</title>
      <link>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-03/</link>
      <pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-03/</guid>
      <description>shebang
第一行代码#!/usr/bin/python3 的理解：
分成两种情况：
（1）如果调用python脚本时，使用:
python script.py  #!/usr/bin/python 被忽略，等同于注释。
（2）如果调用python脚本时，使用:
./script.py  #!/usr/bin/python 指定解释器的路径。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>自然语言处理入门</title>
      <link>https://sanbeichahegongheguo.github.io/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/</guid>
      <description>一、文本相似度计算 文本相似度计算在信息检索、数据挖掘、机器翻译、文档复制检测等领域有着广泛的应用。文本相似度常用的计算方法有TF-IDF、LSI、LDA等。
TF-IDF模型 TF-IDF（Term Frequency-Inverse Document Frequency）是一种统计方法，用以评估某一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。
 字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。
 TF-IDF加权的各种形式常被搜寻引擎应用，作为文件与用户查询之间相关程度的度量或评级。
在一份给定的文件里，词频 (term frequency, TF) 指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被归一化，以防止它偏向长的文件。
逆向文件频率 (inverse document frequency, IDF) 是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到。
某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。
TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。
LSI模型 LSI（Latent Semantic Indexing）又称为潜在语义分析(LSA)，是在信息检索领域提出来的一个概 念。主要用于解决一词多义（如“bank”一词，可以指银行，也可以指河岸）和一义多词（如“car”和“automobile”具有相同的含义）。依靠余弦相似性的方法并不能很好地解决上述问题，所以提出了潜在语义索引的方法，利用SVD降维的方法将词项和文本映射到一个新的空间。
LDA模型 LDA（Latent Dirichlet Allocation）是一种文档主题生成模型，也称为一个三层贝叶斯概率模型，包含词、主题和文档三层结构。所谓生成模型，就是说，我们认为一篇文章的每个词都是通过“以一定概率选择了某个主题，并从这个主题中以一定概率选择某个词语”这样一个过程得到。文档到主题服从多项式分布，主题到词服从多项式分布。
LDA是一种非监督机器学习技术，可以用来识别大规模文档集（document collection）或语料库（corpus）中潜藏的主题信息。它采用了词袋（bag of words）的方法，这种方法将每一篇文档视为一个词频向量，从而将文本信息转化为了易于建模的数字信息。但是词袋方法没有考虑词与词之间的顺序，这简化了问题的复杂性，同时也为模型的改进提供了契机。每一篇文档代表了一些主题所构成的一个概率分布，而每一个主题又代表了很多单词所构成的一个概率分布。
二、中文文本处理利器snownlp SnowNLP是一个python写的类库，可以方便的处理中文文本内容。如中文分词、词性标注、情感分析、文本分类、提取文本关键词、文本相似度计算等。
snownlp示例如下所示：
# -*- coding: utf-8 -*- &amp;quot;&amp;quot;&amp;quot; Created on Wed May 31 22:28:23 2017 @author: Administrator &amp;quot;&amp;quot;&amp;quot; from snownlp import SnowNLP s = SnowNLP(u&#39;这个东西真心很赞&#39;) s.words # [u&#39;这个&#39;, u&#39;东西&#39;, u&#39;真心&#39;, # u&#39;很&#39;, u&#39;赞&#39;] s.</description>
    </item>
    
  </channel>
</rss>