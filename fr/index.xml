<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程世界</title><link>https://sanbeichahegongheguo.github.io/fr/</link><description>Recent content on 编程世界</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 30 Dec 2000 00:00:00 +0000</lastBuildDate><atom:link href="https://sanbeichahegongheguo.github.io/fr/index.xml" rel="self" type="application/rss+xml"/><item><title>Git入门</title><link>https://sanbeichahegongheguo.github.io/fr/post/git%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 30 Dec 2000 00:00:00 +0000</pubDate><guid>https://sanbeichahegongheguo.github.io/fr/post/git%E5%85%A5%E9%97%A8/</guid><description>&lt;h2 id="一git是什么">一、Git是什么&lt;/h2>
&lt;p>1、&lt;/p>
&lt;p>2、&lt;/p>
&lt;h2 id="二git基本用法">二、Git基本用法&lt;/h2>
&lt;p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。&lt;/p>
&lt;p>&lt;img src="./images/bg2015120901.png" alt="img">&lt;/p>
&lt;p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Workspace：工作区&lt;/li>
&lt;li>Index / Stage：暂存区&lt;/li>
&lt;li>Repository：仓库区（或本地仓库）&lt;/li>
&lt;li>Remote：远程仓库&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="一新建代码库">一、新建代码库&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git init &lt;span class="c1"># 在当前目录新建一个Git代码库&lt;/span>
git init &lt;span class="o">[&lt;/span>project-name&lt;span class="o">]&lt;/span> &lt;span class="c1"># 新建一个目录，将其初始化为Git代码库&lt;/span>
git clone &lt;span class="o">[&lt;/span>url&lt;span class="o">]&lt;/span> &lt;span class="c1"># 下载一个项目和它的整个代码历史&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="二配置">二、配置&lt;/h3>
&lt;p>Git的设置文件为**.gitconfig**，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git config --list &lt;span class="c1"># 显示当前的Git配置&lt;/span>
git config -e &lt;span class="o">[&lt;/span>--global&lt;span class="o">]&lt;/span> &lt;span class="c1"># 编辑Git配置文件&lt;/span>
git config &lt;span class="o">[&lt;/span>--global&lt;span class="o">]&lt;/span> user.name &lt;span class="s2">&amp;#34;[name]&amp;#34;&lt;/span> &lt;span class="c1"># 设置提交代码时的用户信息&lt;/span>
git config &lt;span class="o">[&lt;/span>--global&lt;span class="o">]&lt;/span> user.email &lt;span class="s2">&amp;#34;[email address]&amp;#34;&lt;/span> &lt;span class="c1"># 设置提交代码时的用户信息&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="三增加删除文件">三、增加/删除文件&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git add &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ... &lt;span class="c1"># 添加指定文件到暂存区&lt;/span>
git add &lt;span class="o">[&lt;/span>dir&lt;span class="o">]&lt;/span> &lt;span class="c1"># 添加指定目录到暂存区，包括子目录&lt;/span>
git add . &lt;span class="c1"># 添加当前目录的所有文件到暂存区&lt;/span>
git add -p &lt;span class="c1"># 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交&lt;/span>
git rm &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ... &lt;span class="c1"># 删除工作区文件，并且将这次删除放入暂存区&lt;/span>
git rm --cached &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span> &lt;span class="c1"># 停止追踪指定文件，但该文件会保留在工作区&lt;/span>
git mv &lt;span class="o">[&lt;/span>file-original&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file-renamed&lt;span class="o">]&lt;/span> &lt;span class="c1"># 改名文件，并且将这个改名放入暂存区&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="四代码提交">四、代码提交&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git commit -m &lt;span class="o">[&lt;/span>message&lt;span class="o">]&lt;/span> &lt;span class="c1"># 提交暂存区到仓库区&lt;/span>
git commit &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ... -m &lt;span class="o">[&lt;/span>message&lt;span class="o">]&lt;/span> &lt;span class="c1"># 提交暂存区的指定文件到仓库区&lt;/span>
git commit -a &lt;span class="c1"># 提交工作区自上次commit之后的变化，直接到仓库区&lt;/span>
git commit -v &lt;span class="c1"># 提交时显示所有diff信息&lt;/span>
git commit --amend -m &lt;span class="o">[&lt;/span>message&lt;span class="o">]&lt;/span> &lt;span class="c1"># 使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息&lt;/span>
git commit --amend &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ... &lt;span class="c1"># 重做上一次commit，并包括指定文件的新变化&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="五分支">五、分支&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 列出所有本地分支&lt;/span>
$ git branch
&lt;span class="c1"># 列出所有远程分支&lt;/span>
$ git branch -r
&lt;span class="c1"># 列出所有本地分支和远程分支&lt;/span>
$ git branch -a
&lt;span class="c1"># 新建一个分支，但依然停留在当前分支&lt;/span>
$ git branch &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 新建一个分支，并切换到该分支&lt;/span>
$ git checkout -b &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 新建一个分支，指向指定commit&lt;/span>
$ git branch &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 新建一个分支，与指定的远程分支建立追踪关系&lt;/span>
$ git branch --track &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>remote-branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 切换到指定分支，并更新工作区&lt;/span>
$ git checkout &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 切换到上一个分支&lt;/span>
$ git checkout -
&lt;span class="c1"># 建立追踪关系，在现有分支与指定的远程分支之间&lt;/span>
$ git branch --set-upstream &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>remote-branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 合并指定分支到当前分支&lt;/span>
$ git merge &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 选择一个commit，合并进当前分支&lt;/span>
$ git cherry-pick &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除分支&lt;/span>
$ git branch -d &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除远程分支&lt;/span>
$ git push origin --delete &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
$ git branch -dr &lt;span class="o">[&lt;/span>remote/branch&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="六标签">六、标签&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 列出所有tag&lt;/span>
$ git tag
&lt;span class="c1"># 新建一个tag在当前commit&lt;/span>
$ git tag &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 新建一个tag在指定commit&lt;/span>
$ git tag &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除本地tag&lt;/span>
$ git tag -d &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除远程tag&lt;/span>
$ git push origin :refs/tags/&lt;span class="o">[&lt;/span>tagName&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 查看tag信息&lt;/span>
$ git show &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 提交指定tag&lt;/span>
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 提交所有tag&lt;/span>
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> --tags
&lt;span class="c1"># 新建一个分支，指向某个tag&lt;/span>
$ git checkout -b &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="七查看信息">七、查看信息&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 显示有变更的文件&lt;/span>
$ git status
&lt;span class="c1"># 显示当前分支的版本历史&lt;/span>
$ git log
&lt;span class="c1"># 显示commit历史，以及每次commit发生变更的文件&lt;/span>
$ git log --stat
&lt;span class="c1"># 搜索提交历史，根据关键词&lt;/span>
$ git log -S &lt;span class="o">[&lt;/span>keyword&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示某个commit之后的所有变动，每个commit占据一行&lt;/span>
$ git log &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span> HEAD --pretty&lt;span class="o">=&lt;/span>format:%s
&lt;span class="c1"># 显示某个commit之后的所有变动，其&amp;#34;提交说明&amp;#34;必须符合搜索条件&lt;/span>
$ git log &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span> HEAD --grep feature
&lt;span class="c1"># 显示某个文件的版本历史，包括文件改名&lt;/span>
$ git log --follow &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
$ git whatchanged &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示指定文件相关的每一次diff&lt;/span>
$ git log -p &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示过去5次提交&lt;/span>
$ git log -5 --pretty --oneline
&lt;span class="c1"># 显示所有提交过的用户，按提交次数排序&lt;/span>
$ git shortlog -sn
&lt;span class="c1"># 显示指定文件是什么人在什么时间修改过&lt;/span>
$ git blame &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示暂存区和工作区的差异&lt;/span>
$ git diff
&lt;span class="c1"># 显示暂存区和上一个commit的差异&lt;/span>
$ git diff --cached &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示工作区与当前分支最新commit之间的差异&lt;/span>
$ git diff HEAD
&lt;span class="c1"># 显示两次提交之间的差异&lt;/span>
$ git diff &lt;span class="o">[&lt;/span>first-branch&lt;span class="o">]&lt;/span>...&lt;span class="o">[&lt;/span>second-branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示今天你写了多少行代码&lt;/span>
$ git diff --shortstat &lt;span class="s2">&amp;#34;@{0 day ago}&amp;#34;&lt;/span>
&lt;span class="c1"># 显示某次提交的元数据和内容变化&lt;/span>
$ git show &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示某次提交发生变化的文件&lt;/span>
$ git show --name-only &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示某次提交时，某个文件的内容&lt;/span>
$ git show &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>:&lt;span class="o">[&lt;/span>filename&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示当前分支的最近几次提交&lt;/span>
$ git reflog
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="八远程同步">八、远程同步&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git fetch &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="c1"># 下载远程仓库的所有变动&lt;/span>
git remote -v &lt;span class="c1"># 显示所有远程仓库&lt;/span>
git remote show &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="c1"># 显示某个远程仓库的信息&lt;/span>
git remote add &lt;span class="o">[&lt;/span>shortname&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>url&lt;span class="o">]&lt;/span> &lt;span class="c1"># 增加一个新的远程仓库，并命名&lt;/span>
git pull &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="c1"># 取回远程仓库的变化，并与本地分支合并&lt;/span>
git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="c1"># 上传本地指定分支到远程仓库&lt;/span>
git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> --force &lt;span class="c1"># 强行推送当前分支到远程仓库，即使有冲突&lt;/span>
git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> --all &lt;span class="c1"># 推送所有分支到远程仓库&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="九撤销">九、撤销&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span> &lt;span class="c1"># 恢复暂存区的指定文件到工作区&lt;/span>
git checkout &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span> &lt;span class="c1"># 恢复某个commit的指定文件到暂存区和工作区&lt;/span>
git checkout . &lt;span class="c1"># 恢复暂存区的所有文件到工作区&lt;/span>
git reset &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span> &lt;span class="c1"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变&lt;/span>
git reset --hard &lt;span class="c1"># 重置暂存区与工作区，与上一次commit保持一致&lt;/span>
git reset &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span> &lt;span class="c1"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变&lt;/span>
git reset --hard &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span> &lt;span class="c1"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致&lt;/span>
git reset --keep &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span> &lt;span class="c1"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变&lt;/span>
git revert &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span> &lt;span class="c1"># 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支&lt;/span>
git stash &lt;span class="c1"># 暂时将未提交的变化移除，稍后再移入&lt;/span>
git stash pop
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="十其他">十、其他&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git archive &lt;span class="c1"># 生成一个可供发布的压缩包&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="十一常见出错">十一、常见出错&lt;/h3>
&lt;p>如果输入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git remote add origin git@github.com:djqiang（github帐号名）/gitdemo（项目名）.git
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>提示出错信息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">fatal: remote origin already exists.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>解决办法如下：&lt;/p>
&lt;p>1、先输入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git remote rm origin
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>2、再输入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git remote add origin git@github.com:djqiang/gitdemo.git
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就不会报错了！&lt;/p>
&lt;p>3、如果输入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git remote rm origin
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>还是报错的话，&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">error: Could not remove config section &lt;span class="s1">&amp;#39;remote.origin&amp;#39;&lt;/span>.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们需要修改&lt;strong>gitconfig&lt;/strong>文件的内容。&lt;/p>
&lt;p>4、找到你的github的安装路径，我的是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>5、找到一个名为gitconfig的文件，打开它把里面的[remote &amp;ldquo;origin&amp;rdquo;]那一行删掉就好了！&lt;/p>
&lt;h2 id="三github">三、Github&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="三github-如何设置ssh-key">三、github-如何设置SSH Key&lt;/h3>
&lt;h5 id="设置ssh-key">设置SSH Key&lt;/h5>
&lt;h5 id="在注册好github账号后打开你的电脑桌面上的一个文件夹这就建立了一个本地工作库在里面点击鼠标右键找到你的git-bash-here-点击开如图所示进行下面操作">在注册好github账号后，打开你的电脑桌面上的一个文件夹，这就建立了一个本地工作库，在里面点击鼠标右键，找到你的git bash here-点击开，如图所示：进行下面操作：&lt;/h5>
&lt;p>输入cd ~/.ssh——回车（看你是否有了ssh key 密钥，有了就备份）；&lt;img src="./images/1019973-20161014215813156-173847236.png" alt="img">&lt;/p>
&lt;p>输入ssh-keygen -t rsa -C &amp;ldquo;your email&amp;rdquo;——直接回车，之后会让你输入github的账号密码，会出现如图所示结果，跟着上面所指示的路径，在你的电脑中找到该文件，id_rsa文件即是你的私有密钥，id_rsa.pub是共开密钥
&lt;img src="./images/1019973-20161014220913750-1073898620.png" alt="img">&lt;/p>
&lt;p>打开你的id_rsa.pub文件，复制下里面的内容，然后登录进去你的github；
&lt;img src="./images/1019973-20161014215928812-624526387.png" alt="img">&lt;/p>
&lt;p>在右上角账户那里点击头像边上的下拉，出现如图——点击settings进去，找到左侧的SSH Keys,点击，如图；
&lt;img src="./images/1019973-20161014215945750-1095096006.png" alt="img">
&lt;img src="./images/1019973-20161014220034953-1142334622.png" alt="img">&lt;/p>
&lt;p>在点击Add SSH Key，在title处填入任意的标识，在Key部分里面添加刚才复制的id_rsa.pub文件里的内容，点击添加即可；&lt;img src="./images/1019973-20161014220018765-196157985.png" alt="img">&lt;/p>
&lt;p>最后只需测试一下链接是否正常即可。接着输入：ssh -T &lt;a href="mailto:git@github.com">git@github.com&lt;/a>，这时会问是否继续连接，我们输入 yes，这样，我们的git配置就完成了。&lt;/p>
&lt;p>&amp;mdash;EOF&amp;mdash;&lt;/p>
&lt;p>&lt;em>EOF&lt;/em>是一个计算机术语，为&lt;code>End Of File&lt;/code>的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。&lt;/p>
&lt;p>本人公众号&lt;code>火山灰&lt;/code>，亦可搜&lt;code>time_ash_past&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/sanbeichahegongheguo/sanbeichahegongheguo.github.io/master/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="">&lt;/p></description></item><item><title>superset入门</title><link>https://sanbeichahegongheguo.github.io/fr/post/superset%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 30 Dec 2000 00:00:00 +0000</pubDate><guid>https://sanbeichahegongheguo.github.io/fr/post/superset%E5%85%A5%E9%97%A8/</guid><description>&lt;p>&lt;code>superset&lt;/code>是什么？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker run -d -p 8088:8088 -v /dockerfs/superset/conf:/etc/superset -v mkdir /dockerfs/superset/data:/data --name superset amancevice/superset:0.18.5
docker run -d -p 8088:8088 -v D:/Data/sqlite:/home/superset amancevice/superset:0.20.0
docker run -d -p 8088:8088 -v /dockerfs/superset/conf:/home/superset amancevice/superset:lastest
docker &lt;span class="nb">exec&lt;/span> -it &amp;lt;dockerID&amp;gt;fabmanager create-admin --app superset
docker &lt;span class="nb">exec&lt;/span> -it &amp;lt;dockerID&amp;gt;superset db upgrade
docker &lt;span class="nb">exec&lt;/span> -it &amp;lt;dockerID&amp;gt;superset init
docker &lt;span class="nb">exec&lt;/span> -it &amp;lt;dockerID&amp;gt;superset runserver
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&amp;ndash;END&amp;ndash;&lt;/p></description></item><item><title>GitHub使用入门及问题汇集</title><link>https://sanbeichahegongheguo.github.io/fr/post/github%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 28 Mar 2000 00:00:00 +0000</pubDate><guid>https://sanbeichahegongheguo.github.io/fr/post/github%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>&lt;hr>
&lt;p>作者：荒野雄兵&lt;/p>
&lt;p>来源：CSDN&lt;/p>
&lt;p>原文：https://blog.csdn.net/daerzei/article/details/79528153&lt;/p>
&lt;p>版权声明：本文为博主原创文章，转载请附上博文链接！&lt;/p>
&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Push failed: Failed with error: unable to access &lt;span class="s1">&amp;#39;https://github.com/********&amp;#39;&lt;/span>:
OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&amp;mdash;EOF&amp;mdash;&lt;/p>
&lt;p>&lt;em>EOF&lt;/em>是一个计算机术语，为&lt;code>End Of File&lt;/code>的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。&lt;/p>
&lt;p>本人公众号&lt;code>火山灰&lt;/code>，亦可搜&lt;code>time_ash_past&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/sanbeichahegongheguo/sanbeichahegongheguo.github.io/master/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="">&lt;/p></description></item><item><title>RSA算法解释</title><link>https://sanbeichahegongheguo.github.io/fr/post/rsa%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sanbeichahegongheguo.github.io/fr/post/rsa%E7%AE%97%E6%B3%95/</guid><description>&lt;p>彻底讲清楚。&lt;/p>
&lt;h2 id="一一点历史">一、一点历史&lt;/h2>
&lt;p>1976年以前，所有的加密方法都是同一种模式：&lt;/p>
&lt;blockquote>
&lt;p>（1）甲方选择&lt;strong>某一种加密规则&lt;/strong>，对信息进行加密；&lt;/p>
&lt;p>（2）乙方使用&lt;strong>同一种规则&lt;/strong>，对信息进行解密。&lt;/p>
&lt;/blockquote>
&lt;p>由于加密和解密使用同样规则（简称&amp;quot;密钥&amp;quot;），这被称为&amp;quot;对称加密算法&amp;quot;（Symmetric-key algorithm）。&lt;/p>
&lt;p>这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。&lt;/p>
&lt;p>1976年，两位美国计算机学家&lt;code>Whitfield Diffie&lt;/code>和&lt;code>Martin Hellman&lt;/code>，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为&amp;quot;Diffie-Hellman密钥交换算法&amp;quot;。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。&lt;/p>
&lt;p>这种新的加密模式被称为&amp;quot;非对称加密算法&amp;quot;。&lt;/p>
&lt;blockquote>
&lt;p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。&lt;/p>
&lt;p>（2）甲方获取乙方的公钥，然后用它对信息加密。&lt;/p>
&lt;p>（3）乙方得到加密后的信息，用私钥解密。&lt;/p>
&lt;/blockquote>
&lt;p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。&lt;/p>
&lt;p>1977年，三位数学家&lt;code>Rivest&lt;/code>、&lt;code>Shamir&lt;/code>和&lt;code>Adleman&lt;/code>设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的&amp;quot;非对称加密算法&amp;quot;。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。&lt;/p>
&lt;p>这种算法非常&lt;a href="http://en.wikipedia.org/wiki/RSA_Factoring_Challenge">可靠&lt;/a>，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。&lt;/p>
&lt;p>下面，我就进入正题，解释RSA算法的原理。文章共分成两部分，今天是第一部分，介绍要用到的四个数学概念。你可以看到，RSA算法并不难，只需要一点&lt;a href="http://jeremykun.com/2011/07/30/number-theory-a-primer/">数论知识&lt;/a>就可以理解。&lt;/p>
&lt;h2 id="二数论基础">二、数论基础&lt;/h2>
&lt;h4 id="1互质关系">1、互质关系&lt;/h4>
&lt;p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是&lt;a href="http://zh.wikipedia.org/zh-cn/互素">互质关系&lt;/a>（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。&lt;/p>
&lt;p>关于互质关系，不难得到以下结论：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>&lt;p>任意两个质数构成互质关系，比如13和61。&lt;/p>&lt;/li>
&lt;li>&lt;p>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。&lt;/p>&lt;/li>
&lt;li>&lt;p>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。&lt;/p>&lt;/li>
&lt;li>&lt;p>1和任意一个自然数是都是互质关系，比如1和99。&lt;/p>&lt;/li>
&lt;li>&lt;p>p是大于1的整数，则p和p-1构成互质关系，比如57和56。&lt;/p>&lt;/li>
&lt;li>&lt;p>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。&lt;/p>&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h4 id="2欧拉函数">2、欧拉函数&lt;/h4>
&lt;p>请思考以下问题：&lt;/p>
&lt;blockquote>
&lt;p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？&lt;/p>
&lt;p>（比如，在1到8之中，有多少个数与8构成互质关系？）&lt;/p>
&lt;/blockquote>
&lt;p>计算这个值的方法（或者说函数）就叫做&lt;a href="http://zh.wikipedia.org/wiki/欧拉函数">欧拉函数&lt;/a>，以&lt;span class="math">\(φ(n)\)&lt;/span>表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 &lt;span class="math">\( φ(n) = 4 \)&lt;/span>。&lt;/p>
&lt;p>&lt;span class="math">\(φ(n)\)&lt;/span>的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。&lt;/p>
&lt;p>&lt;strong>第一种情况&lt;/strong>&lt;/p>
&lt;p>如果&lt;span class="math">\( n = 1 \)&lt;/span>，则 &lt;span class="math">\( φ(1) = 1 \)&lt;/span>。因为1与任何数（包括自身）都构成互质关系。&lt;/p>
&lt;p>&lt;strong>第二种情况&lt;/strong>&lt;/p>
&lt;p>如果&lt;span class="math">\(n\)&lt;/span>是质数，则 &lt;span class="math">\( φ(n) = n-1 \)&lt;/span>。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。&lt;/p>
&lt;p>&lt;strong>第三种情况&lt;/strong>&lt;/p>
&lt;p>如果$n$是质数的某一个次方，即 &lt;span class="math">\( n = p^k \)&lt;/span> (p为质数，k为大于等于1的整数)，则：
&lt;span class="math">\(
φ(n)=φ(p^k) =p^k - p^{k-1}
\)&lt;/span>
比如 &lt;span class="math">\(φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4\)&lt;/span>。&lt;/p>
&lt;p>这是因为&lt;span class="math">\( n \)&lt;/span>是质数的某一个次方，那只有从1到&lt;span class="math">\(n\)&lt;/span>中一个不包含质数p的数，才可能与$n$互质。而包含质数p的数一共有&lt;span class="math">\( p^{(k-1)} \)&lt;/span>个，即&lt;span class="math">\( 1×p、2×p、3×p、…、p^{(k-1)}×p \)&lt;/span>，把它们去除，剩下的就是与&lt;span class="math">\( n \)&lt;/span>互质的数。&lt;/p>
&lt;p>上面的式子还可以写成下面的形式：
&lt;span class="math">\(
φ(n)=φ(p^k) =p^k - p^{k-1}=p^k(1-\frac{1}{p})
\)&lt;/span>
可以看出，上面的第二种情况是 k=1 时的特例。&lt;/p>
&lt;p>&lt;strong>第四种情况&lt;/strong>&lt;/p>
&lt;p>如果n可以分解成两个互质的整数之积，&lt;span class="math">\( n = p_1 × p_2 \)&lt;/span>，&lt;/p>
&lt;p>则
&lt;span class="math">\(
φ(n) = φ(p_1p_2) = φ(p_1)φ(p_2)
\)&lt;/span>
即积的欧拉函数等于各个因子的欧拉函数之积。比如，&lt;span class="math">\(φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24\)&lt;/span>。&lt;/p>
&lt;p>这一条的证明要用到&lt;a href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem">&amp;quot;中国剩余定理&amp;quot;&lt;/a>，结尾展开了，这里先只简单说一下思路：如果&lt;span class="math">\( a \)&lt;/span>与&lt;span class="math">\( p_1 \)&lt;/span>互质（&lt;span class="math">\( a&lt;p_1 \)&lt;/span>），&lt;span class="math">\( b \)&lt;/span>与&lt;span class="math">\( p_2 \)&lt;/span>互质（&lt;span class="math">\( b&lt;p_2 \)&lt;/span>），&lt;span class="math">\( c \)&lt;/span>与&lt;span class="math">\( p_1p_2 \)&lt;/span>互质（&lt;span class="math">\( c&lt;p_1p_2 \)&lt;/span>），则&lt;span class="math">\( c \)&lt;/span>与数对&lt;span class="math">\( (a,b) \)&lt;/span>是一一对应关系。由于&lt;span class="math">\( a \)&lt;/span>的值有&lt;span class="math">\( φ(p_1) \)&lt;/span>种可能，&lt;span class="math">\( b \)&lt;/span>的值有&lt;span class="math">\( φ(p_2) \)&lt;/span>种可能，则数对&lt;span class="math">\( (a,b) \)&lt;/span>有&lt;span class="math">\( φ(p_1)φ(p_2) \)&lt;/span>种可能，而&lt;span class="math">\( c \)&lt;/span>的值有&lt;span class="math">\( φ(p_1p_2) \)&lt;/span>种可能，所以&lt;span class="math">\( φ(p_1p_2) \)&lt;/span>就等于&lt;span class="math">\( φ(p_1)φ(p_2) \)&lt;/span>。&lt;/p>
&lt;p>&lt;strong>第五种情况&lt;/strong>&lt;/p>
&lt;p>因为任意一个大于1的正整数，都可以写成一系列质数的积。&lt;/p>
&lt;p>&lt;span class="math">\[ n=p^{k_1}_1p^{k_2}_2...p^{k_r}_r \]&lt;/span>&lt;/p>
&lt;p>根据第4条的结论，得到：
&lt;span class="math">\(
φ(n)=φ(p^{k_1}_1)φ(p^{k_2}_2)...φ(p^{k_r}_r)
\)&lt;/span>&lt;/p>
&lt;p>再根据第3条的结论，得到
&lt;span class="math">\(
φ(n)=\\
p^{k_1}_1p^{k_2}_2...p^{k_r}_r
×
(1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_r})\\
=\\
n(1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_r})
\)&lt;/span>&lt;/p>
&lt;p>这就是欧拉函数的通用计算公式。比如，&lt;code>1323&lt;/code>的欧拉函数，计算过程如下：&lt;/p>
&lt;p>&lt;span class="math">\[ φ(1323)=φ(3^3×7^2)=1323×(1-\frac{1}{3})×(1-\frac{1}{7})=756 \]&lt;/span>&lt;/p>
&lt;h4 id="3欧拉定理">3、欧拉定理&lt;/h4>
&lt;p>欧拉函数的用处，在于证明&lt;a href="http://zh.wikipedia.org/wiki/欧拉定理_(数论)">欧拉定理&lt;/a>。&amp;quot;欧拉定理&amp;quot;指的是：&lt;/p>
&lt;blockquote>
&lt;p>如果两个正整数a和n互质，则n的欧拉函数$φ(n)$可以让下面的等式成立：&lt;/p>
&lt;p>&lt;span class="math">\[ a^{φ(n)}\equiv 1\pmod n \]&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>也就是说，a的$φ(n)$次方被n除的余数为1。或者说，a的&lt;span class="math">\( φ(n) \)&lt;/span>次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数&lt;span class="math">\( φ(7) \)&lt;/span>等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。&lt;/p>
&lt;p>欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。&lt;/p>
&lt;p>欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，&lt;/p>
&lt;p>&lt;span class="math">\[ 7^{φ(10)}\equiv 1\pmod {10} \]&lt;/span>&lt;/p>
&lt;p>已知&lt;span class="math">\( φ(10) \)&lt;/span> 等于4，在十进制下，可以得到7的4倍数次方的个位数肯定是1：&lt;/p>
&lt;p>&lt;span class="math">\[ 7^{4k}\equiv 1\pmod {10} \]&lt;/span>&lt;/p>
&lt;p>因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。&lt;/p>
&lt;p>欧拉定理有一个特殊情况。&lt;/p>
&lt;blockquote>
&lt;p>假设正整数&lt;span class="math">\( a \)&lt;/span>与质数&lt;span class="math">\( p \)&lt;/span>互质，因为质数&lt;span class="math">\( p \)&lt;/span>的&lt;span class="math">\( φ(p) \)&lt;/span>等于&lt;span class="math">\( p-1 \)&lt;/span>，则欧拉定理可以写成&lt;/p>
&lt;p>&lt;span class="math">\[ a^{p-1}\equiv 1\pmod {p} \]&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>这就是著名的&lt;a href="http://zh.wikipedia.org/wiki/费马小定理">费马小定理&lt;/a>。它是欧拉定理的特例。&lt;/p>
&lt;p>欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。&lt;/p>
&lt;h4 id="4模反元素">4、模反元素&lt;/h4>
&lt;p>还剩下最后一个概念：&lt;/p>
&lt;blockquote>
&lt;p>如果两个正整数&lt;span class="math">\( a \)&lt;/span>和&lt;span class="math">\( n \)&lt;/span>互质，那么一定可以找到整数&lt;span class="math">\( b \)&lt;/span>，使得&lt;span class="math">\( a×b-1 \)&lt;/span>被&lt;span class="math">\( n \)&lt;/span>整除，或者说&lt;span class="math">\( a×b \)&lt;/span>被&lt;span class="math">\( n \)&lt;/span>除的余数是1。&lt;/p>
&lt;p>&lt;span class="math">\[ a×b\equiv 1\pmod {n} \]&lt;/span>&lt;/p>
&lt;p>这时，b就叫做a的&lt;a href="http://zh.wikipedia.org/wiki/模反元素">&amp;quot;模反元素&amp;quot;&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 ，即如果b是a的模反元素，则 b+kn 都是a的模反元素。&lt;/p>
&lt;p>欧拉定理可以用来证明模反元素必然存在。&lt;/p>
&lt;p>&lt;span class="..,-18,-7,4,15,26,..." class="math">\[ a^{φ(n)}=a×a^{φ(n)-1}\equiv 1\pmod n \]&lt;/span>&lt;/p>
&lt;p>令&lt;span class="..,-18,-7,4,15,26,..." class="math">\( b=a^{φ(n)-1}$，$ab\equiv 1\pmod {n } \)&lt;/span>。&lt;/p>
&lt;p>可以看到，&lt;span class="..,-18,-7,4,15,26,..." class="math">\( a \)&lt;/span>的&lt;span class="..,-18,-7,4,15,26,..." class="math">\( φ(n)-1 \)&lt;/span>次方，就是&lt;span class="..,-18,-7,4,15,26,..." class="math">\( a \)&lt;/span>的模反元素。&lt;/p>
&lt;h2 id="三rsa算法">三、RSA算法&lt;/h2>
&lt;h4 id="1初始化">1、初始化&lt;/h4>
&lt;p>RSA算法涉及的数学知识，就是上面这些。&lt;/p>
&lt;p>我们通过一个例子，来理解RSA算法。假设&lt;a href="http://zh.wikipedia.org/wiki/爱丽丝与鲍伯">爱丽丝&lt;/a>要与鲍勃进行加密通信，首先是鲍勃要给爱丽丝发消息，爱丽丝该怎么处理呢？&lt;/p>
&lt;p>她需要自己生成公钥和私钥，把公钥通过公开的可验证路径公开出来，当然，鲍勃也可以获取到。&lt;/p>
&lt;p>&lt;figure>&lt;img src="http://www.ruanyifeng.com/blogimg/asset/201307/bg2013070302.png" alt="img">&lt;/figure>&lt;/p>
&lt;p>&lt;strong>第一步，随机选择两个不相等的质数p和q。&lt;/strong>&lt;/p>
&lt;p>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）&lt;/p>
&lt;p>&lt;strong>第二步，计算p和q的乘积n。&lt;/strong>&lt;/p>
&lt;p>爱丽丝就把61和53相乘。&lt;/p>
&lt;blockquote>
&lt;p>n = 61×53 = 3233&lt;/p>
&lt;/blockquote>
&lt;p>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。&lt;/p>
&lt;p>&lt;strong>第三步，计算n的欧拉函数φ(n)。&lt;/strong>&lt;/p>
&lt;p>根据公式：&lt;/p>
&lt;p>&lt;span class="math">\[ φ(n) = φ(p×q)=φ(p)×φ(q)=(p-1)×(q-1) \]&lt;/span>&lt;/p>
&lt;p>爱丽丝算出&lt;span class="math">\( φ(3233) \)&lt;/span>等于60×52，即3120。&lt;/p>
&lt;p>&lt;strong>第四步，随机选择一个整数e，条件是&lt;span class="math">\( 1&lt; e &lt; φ(n) \)&lt;/span>，且e与φ(n) 互质。&lt;/strong>&lt;/p>
&lt;p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）&lt;/p>
&lt;p>&lt;strong>第五步，计算e对于φ(n)的模反元素d。&lt;/strong>&lt;/p>
&lt;p>&lt;span class="math">\[ e×d ≡ 1 \pmod{φ(n)} \]&lt;/span>&lt;/p>
&lt;p>这个式子等价于：&lt;/p>
&lt;p>&lt;span class="math">\[ e×d - 1 = k×φ(n) \]&lt;/span>&lt;/p>
&lt;p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解：&lt;/p>
&lt;p>&lt;span class="math">\[ ex + φ(n)y = 1，其中x=d，y=-k \]&lt;/span>&lt;/p>
&lt;p>已知 e=17, φ(n)=3120，&lt;/p>
&lt;blockquote>
&lt;p>17x + 3120y = 1&lt;/p>
&lt;/blockquote>
&lt;p>这个方程可以用&lt;a href="http://zh.wikipedia.org/wiki/扩展欧几里得算法">&amp;quot;扩展欧几里得算法&amp;quot;&lt;/a>求解，此处省略具体过程。&lt;/p>
&lt;p>总之，爱丽丝算出一组整数解为&lt;span class="math">\( (x,y)=(2753,-15) \)&lt;/span>，即 d = 2753。&lt;/p>
&lt;p>至此爱丽丝这边所有计算完成。&lt;/p>
&lt;p>&lt;strong>第六步，将n和e封装成公钥（n，e），n和d封装成私钥（n，d）。&lt;/strong>&lt;/p>
&lt;p>在爱丽丝的例子中，$n=3233，e=17，d=2753$，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。&lt;/p>
&lt;p>实际应用中，公钥和私钥的数据都采用&lt;a href="http://zh.wikipedia.org/zh-cn/ASN.1">ASN.1&lt;/a>格式表达（&lt;a href="http://hi.baidu.com/mathack/item/d0ad4cc1514a3663f7c95da2">实例&lt;/a>）。&lt;/p>
&lt;p>然后把公钥发布出去。通常是发布到一个权威的第三方网站，可供所有人任意访问获取。如果有人想给爱丽丝发送保密信息，就通过这些第三方网站查找到爱丽丝的公钥然后去加密。&lt;/p>
&lt;h4 id="2加密和解密">2、加密和解密&lt;/h4>
&lt;p>有了公钥和密钥，就能进行加密和解密了。&lt;/p>
&lt;p>&lt;strong>（1）加密要用公钥 (n,e)&lt;/strong>&lt;/p>
&lt;p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取&lt;code>ascii&lt;/code>值或&lt;code>unicode&lt;/code>值），且m必须小于n。&lt;/p>
&lt;p>所谓&amp;quot;加密&amp;quot;，就是算出下式的c：&lt;/p>
&lt;p>&lt;span class="math">\[ m^e ≡ c \pmod n \]&lt;/span>&lt;/p>
&lt;p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：&lt;/p>
&lt;p>&lt;span class="math">\[ 65^{17} ≡ 2790 \pmod {3233} \]&lt;/span>&lt;/p>
&lt;p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。&lt;/p>
&lt;p>&lt;strong>（2）解密要用私钥(n,d)&lt;/strong>&lt;/p>
&lt;p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。&lt;/p>
&lt;p>可以证明，下面的等式一定成立：&lt;/p>
&lt;p>&lt;span class="math">\[ c^d ≡ m \pmod n \]&lt;/span>&lt;/p>
&lt;p>也就是说，c的d次方除以n的余数为m。&lt;/p>
&lt;p>现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出&lt;/p>
&lt;p>&lt;span class="math">\[ 2790^{2753} ≡ 65 \pmod {3233} \]&lt;/span>&lt;/p>
&lt;p>因此，爱丽丝知道了鲍勃加密前的原文就是65。&lt;/p>
&lt;p>至此，&amp;quot;加密--解密&amp;quot;的整个过程全部完成。&lt;/p>
&lt;p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。&lt;/p>
&lt;p>这里有个问题，&lt;strong>公钥(n，e) 只能加密小于n的整数m&lt;/strong>，那么如果现实中要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种&amp;quot;对称性加密算法&amp;quot;（比如&lt;a href="https://zh.wikipedia.org/wiki/资料加密标准">DES&lt;/a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥，这里设置DES密钥小于n即可。&lt;/p>
&lt;p>综合以上计算过程，需要计算的过程是初始化取的两个质数，并根据质数的乘积结果的欧拉函数结果再自行选择一个私钥。之后就是乘法和求模运算。&lt;/p>
&lt;h4 id="3rsa算法的可靠性">3、RSA算法的可靠性&lt;/h4>
&lt;p>回顾上面的密钥生成步骤，一共出现六个数字：&lt;/p>
&lt;blockquote>
&lt;p>　　p
　　
　　q
　　
　　n
　　
　　φ(n)
　　
　　e
　　
　　d&lt;/p>
&lt;/blockquote>
&lt;p>这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。&lt;/p>
&lt;p>&lt;strong>那么，有无可能在已知n和e的情况下，推导出d？&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>（1）&lt;span class="math">\( ed≡1 \pmod {φ(n)} \)&lt;/span>。只有知道e和&lt;span class="math">\( φ(n) \)&lt;/span>，才能算出d。&lt;/p>
&lt;p>（2）&lt;span class="math">\( φ(n)=(p-1)(q-1) \)&lt;/span>。只有知道p和q，才能算出&lt;span class="math">\( φ(n) \)&lt;/span>。&lt;/p>
&lt;p>（3）&lt;span class="math">\( n=p×q \)&lt;/span>。只有将n因数分解，才能算出p和q。&lt;/p>
&lt;/blockquote>
&lt;p>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。&lt;/p>
&lt;p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：&lt;/p>
&lt;blockquote>
&lt;p>&amp;quot;对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。&lt;/p>
&lt;p>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。&lt;/p>
&lt;p>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。&amp;quot;&lt;/p>
&lt;/blockquote>
&lt;p>举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。&lt;/p>
&lt;blockquote>
&lt;p>　　1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413&lt;/p>
&lt;/blockquote>
&lt;p>它等于这样两个质数的乘积：&lt;/p>
&lt;blockquote>
&lt;p>　　33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489
　　&lt;/p>
&lt;p>　　　　×
　　36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917&lt;/p>
&lt;/blockquote>
&lt;p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。&lt;/p>
&lt;h4 id="4私钥解密的证明">4、私钥解密的证明&lt;/h4>
&lt;p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到$m$。也就是证明下面这个式子：&lt;/p>
&lt;p>&lt;span class="math">\(
m^e \equiv c \pmod n\\
c^d \equiv m \pmod n\\
其中，e与φ(n) 互质，e×d ≡ 1 \pmod{φ(n)}.
\)&lt;/span>
因为，根据加密规则：&lt;/p>
&lt;p>&lt;span class="math">\[ ｍ^e ≡ c \pmod n \]&lt;/span>&lt;/p>
&lt;p>于是，c可以写成下面的形式：&lt;/p>
&lt;p>&lt;span class="math">\[ c = m^e - kn\]&lt;/span>&lt;/p>
&lt;p>将c代入要我们要证明的那个解密规则：&lt;/p>
&lt;p>&lt;span class="math">\[(m^e - kn)^d ≡ m \pmod n\]&lt;/span>&lt;/p>
&lt;p>我们知道将左式展开所有包含$n$项的式子都可以被&lt;span class="math">\(n\)&lt;/span>整除，所有去掉那些可以被整除的项，仅剩&lt;span class="math">\(m^{ed}\)&lt;/span>，它等同于求证：&lt;/p>
&lt;p>&lt;span class="math">\[m^{ed} ≡ m \pmod n\]&lt;/span>&lt;/p>
&lt;p>由于，&lt;/p>
&lt;p>&lt;span class="math">\[e×d ≡ 1 \pmod {φ(n)}\]&lt;/span>&lt;/p>
&lt;p>所以，&lt;/p>
&lt;p>&lt;span class="math">\[e×d = h×φ(n)+1\]&lt;/span>&lt;/p>
&lt;p>将上式代入得：&lt;/p>
&lt;p>&lt;span class="math">\[m^{hφ(n)+1} ≡ m \pmod n\]&lt;/span>&lt;/p>
&lt;p>接下来，分成两种情况证明上面这个式子。&lt;/p>
&lt;p>&lt;strong>（1）m与n互质。&lt;/strong>&lt;/p>
&lt;p>根据欧拉定理，此时，&lt;/p>
&lt;p>&lt;span class="math">\(m^{φ(n)} ≡ 1 \pmod n\)&lt;/span>，或者说&lt;span class="math">\([m^{φ(n)}]^h ≡ 1 \pmod n\)&lt;/span>&lt;/p>
&lt;p>上式两边同时乘以$m$，就可以得到&lt;/p>
&lt;p>&lt;span class="math">\[[m^{φ(n)}]^h × m ≡ m \pmod n\]&lt;/span>&lt;/p>
&lt;p>原式得到证明。&lt;/p>
&lt;p>&lt;strong>（2）m与n不是互质关系。&lt;/strong>&lt;/p>
&lt;p>此时，由于n等于质数p和q的乘积，所以m必然等于$kp$或$kq$。&lt;/p>
&lt;p>以&lt;span class="math">\(m = kp\)&lt;/span>为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：&lt;/p>
&lt;p>&lt;span class="math">\(m^{φ(q)}≡1 \pmod q\)&lt;/span>，&lt;/p>
&lt;p>因为&lt;span class="math">\(φ(q)=q-1\)&lt;/span>，上式扩展为：&lt;/p>
&lt;p>&lt;span class="math">\[(kp)^{q-1} ≡ 1 \pmod q\]&lt;/span>&lt;/p>
&lt;p>进一步得到，&lt;span class="math">\([(kp)^{q-1}]^{h(p-1)} ≡ 1 \pmod q\)&lt;/span>，两边再乘以&lt;span class="math">\(kp\)&lt;/span>，&lt;/p>
&lt;p>&lt;span class="math">\[[(kp)^{q-1}]^{h(p-1)} × kp ≡ kp \pmod q\]&lt;/span>&lt;/p>
&lt;p>由于&lt;span class="math">\((q-1)(p-1)=φ(n)\)&lt;/span>，且&lt;span class="math">\(ed = hφ(n)+1\)&lt;/span>，则&lt;/p>
&lt;p>&lt;span class="math">\[(kp)^{ed} ≡ kp \pmod q\]&lt;/span>&lt;/p>
&lt;p>将它改写成下面的等式&lt;/p>
&lt;p>&lt;span class="math">\[(kp)^{ed} = tq + kp\]&lt;/span>&lt;/p>
&lt;p>分析式子，三个多项式两个都有&lt;span class="math">\(p\)&lt;/span>，而剩余的&lt;span class="math">\(tq\)&lt;/span>里&lt;span class="math">\(q\)&lt;/span>和&lt;span class="math">\(p\)&lt;/span>互质，那么这时&lt;span class="math">\(t\)&lt;/span>必然要能被&lt;span class="math">\(p\)&lt;/span>整除，即&lt;span class="math">\(t=t'p\)&lt;/span>，那么式子可以写成&lt;/p>
&lt;p>&lt;span class="math">\[(kp)^{ed} = t'pq + kp\]&lt;/span>&lt;/p>
&lt;p>因为&lt;span class="math">\(m=kp，n=pq\)&lt;/span>，所以&lt;/p>
&lt;p>&lt;span class="math">\(m^{ed}=t'n+m\)&lt;/span>，也即&lt;/p>
&lt;p>&lt;span class="math">\[m^{ed} ≡ m \pmod n\]&lt;/span>&lt;/p>
&lt;p>原式得到证明。&lt;/p>
&lt;h4 id="5rsa加密算法的缺点">5、RSA加密算法的缺点&lt;/h4>
&lt;p>虽然RSA加密算法作为目前最优秀的公钥方案之一，在发表三十多年的时间里，经历了各种攻击的考验，逐渐为人们接受。但是，也不是说RSA没有任何缺点。由于没有从理论上证明破译RSA的难度与大数分解难度的等价性。所以，RSA的重大缺陷是无法从理论上把握它的保密性能如何。在实践上，RSA也有一些缺点：&lt;/p>
&lt;ol>
&lt;li>产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密；&lt;/li>
&lt;li>分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢。&lt;/li>
&lt;/ol>
&lt;p>因此现在通常是将RSA和其他加密算法结合，RSA算法加密其他算法其中核心的部分，减轻运算量。&lt;/p>
&lt;h2 id="四实例">四、实例&lt;/h2>
&lt;h4 id="1加密cloud">1、加密cloud&lt;/h4>
&lt;p>取质数13和7，它们相乘的结果为91。&lt;/p>
&lt;p>&lt;span class="math">\(φ(91)=(13-1)×(7-1)=12×6=72\)&lt;/span>，挑一个与72互质的数作为公钥，可选的有5,7,11,13,17等等，简单点就选5位公钥。&lt;/p>
&lt;p>运用&lt;strong>拓展欧几里得算法（辗转相除法）&lt;/strong>，计算出29与5的成绩与72的模结果是1，也即得到私钥是29。&lt;/p>
&lt;blockquote>
&lt;p>　　　　p=13
　　　　q=7
　　　　n=91
　　　　φ(n)=72
　　　　e=5
　　　　d=29&lt;/p>
&lt;/blockquote>
&lt;p>这些参数&lt;code>（max:91，pub:5，priv:29）&lt;/code>定义了一个充分实用型RSA系统。你能取一个数字并且用它乘以它自己5次来加密它，然后取那个数字并且用它乘以它自己29次然后你得回了原来的数字。所以公钥就是 (91, 5)，私钥就是（91, 29）。&lt;/p>
&lt;p>可以用这些标准来加密信息“CLOUD”。&lt;/p>
&lt;p>为了用数字表示这个信息，我们要把字母转换成数字。拉丁字母表的通常代表是&lt;code>UTF-8&lt;/code>，每个字母相当于一个数字。&lt;/p>
&lt;p>在这个编码下，&lt;code>CLOUD&lt;/code>转换成数字是&lt;code>67,76,79,85,68&lt;/code>。这些数字均小于我们的最大值91，所以我们可以单独地加密它们。让我们开始加密第一个字母。&lt;/p>
&lt;p>$67^5≡C\pmod {91}，c=67^5\mod 91$&lt;/p>
&lt;p>可算得c=58。&lt;/p>
&lt;p>也就是说，数字&lt;code>67&lt;/code>的加密值为&lt;code>58&lt;/code>。&lt;/p>
&lt;p>重复这个过程，&lt;code>CLOUD&lt;/code>的数字&lt;code>（67,76,79,85,68）&lt;/code>经过&lt;code>（max:91，pub:5，priv:29）&lt;/code>加密变成&lt;code>（58,20,53,50,87）&lt;/code>。&lt;/p>
&lt;p>解密过程，先解密第一个数字：&lt;/p>
&lt;p>&lt;span class="math">\(58^{29}≡m\pmod {91}，m=58^{29}\mod91\)&lt;/span>，&lt;/p>
&lt;p>解得m=67。&lt;/p>
&lt;p>其余与之类似。&lt;/p>
&lt;h4 id="2ssh-两种验证方式">2、SSH 两种验证方式&lt;/h4>
&lt;h5 id="1用户名密码验证方式">1、用户名密码验证方式&lt;/h5>
&lt;p>&lt;a href="https://images2015.cnblogs.com/blog/828019/201701/828019-20170104111525691-1181039165.png">&lt;figure>&lt;img src="https://images2015.cnblogs.com/blog/828019/201701/828019-20170104111525691-1181039165.png" alt="img">&lt;/figure>&lt;/a>&lt;/p>
&lt;p>说明：&lt;/p>
&lt;p>　　（1） 当客户端发起ssh请求，服务器会把自己的公钥发送给用户；&lt;/p>
&lt;p>　　（2） 用户会根据服务器发来的公钥对密码进行加密；&lt;/p>
&lt;p>　　（3） 加密后的信息回传给服务器，服务器用自己的私钥解密，如果密码正确，则用户登录成功。&lt;/p>
&lt;h5 id="2基于密钥的登录方式">2、基于密钥的登录方式&lt;/h5>
&lt;p>&lt;a href="https://images2015.cnblogs.com/blog/828019/201701/828019-20170104140144831-1650956401.png">&lt;figure>&lt;img src="https://images2015.cnblogs.com/blog/828019/201701/828019-20170104140144831-1650956401.png" alt="img">&lt;/figure>&lt;/a>&lt;/p>
&lt;p>说明：&lt;/p>
&lt;p>　　（1） 首先在客户端生成一对密钥（ssh-keygen）；&lt;/p>
&lt;p>　　（2） 并将客户端的公钥ssh-copy-id 拷贝到服务端；&lt;/p>
&lt;p>　　（3） 当客户端再次发送一个连接请求，包括ip、用户名；&lt;/p>
&lt;p>　　（4） 服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：qwer；&lt;/p>
&lt;p>　　（5） 服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端；&lt;/p>
&lt;p>　　（6） 得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端；&lt;/p>
&lt;p>　　（7） 服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录。&lt;/p>
&lt;blockquote>
&lt;p>作者： hukey&lt;/p>
&lt;p>出处：&lt;a href="https://www.cnblogs.com/hukey/p/6248468.html">https://www.cnblogs.com/hukey/p/6248468.html&lt;/a>&lt;/p>
&lt;p>版权：本作品采用「&lt;a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际&lt;/a>」许可协议进行许可。&lt;/p>
&lt;/blockquote>
&lt;h2 id="五进阶">五、进阶&lt;/h2>
&lt;h5 id="1求模">1、求模&lt;/h5>
&lt;p>&lt;span class="math">\[a^{10} = a^{(0×2^0+1×2^1+0×2^2+1×2^3 )} = a^{(2^1)} × a^{(2^3)}\]&lt;/span>&lt;/p>
&lt;p>--END--&lt;/p></description></item></channel></rss>