<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 火山灰</title>
    <link>https://sanbeichahegongheguo.github.io/</link>
    <description>Recent content in Home on 火山灰</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Jun 2017 18:27:58 +0100</lastBuildDate>
    
	<atom:link href="https://sanbeichahegongheguo.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如何用hugo&#43;github建立自己的博客</title>
      <link>https://sanbeichahegongheguo.github.io/%E5%A6%82%E4%BD%95%E7%94%A8hugo-github%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/%E5%A6%82%E4%BD%95%E7%94%A8hugo-github%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</guid>
      <description>这篇讲讲如何用github+hugo建立自己的博客。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>[转]Linux 系统和 Shell 编程问题录</title>
      <link>https://sanbeichahegongheguo.github.io/linux-%E7%B3%BB%E7%BB%9F%E5%92%8C-shell-%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E5%BD%95/</link>
      <pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/linux-%E7%B3%BB%E7%BB%9F%E5%92%8C-shell-%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E5%BD%95/</guid>
      <description>本文来源：知乎专栏
简答题 1. 计算机硬件和软件的关系是什么？ 硬件是计算机系统的物理组成部分，即计算机系统中的各种物理装置，包括控制器、运算器、内存储器、I/O设备（如硬盘、键盘）以及外存储器等。它是计算机系统的物质基础。
软件系统就是所有程序、数据和相关文件的集合。从狭义的角度上讲，软件是指计算机运行所需的各种程序。没有硬件，谈不上应用计算机。但是，光有硬件而没有软件，计算机也不能工作。（1）硬件和软件互相依存；（2）硬件和软件无严格界线；（3）硬件和软件协同发展。
计算机软件和硬件密不可分，协调工作。软件的运行通过硬件呈现给用户，用户通过硬件进行开发及修改软件，二者相互依存，缺一不可。离开了硬件的软件什么也做不了，离开软件的硬件也只是摆设。对于计算机而言，软件像是灵魂，硬件像是肉体。二者相互依存。同时二者也相互制约。在计算机的早期，硬件很薄弱，限制了计算机的发展；如今，硬件配置很多都很高了，软件的优化对提高计算机的性能十分关键。以手机为例，早期的智能机内存通常只有512MB，提高手机内存是解决手机卡顿的关键因素，而如今，很多手机的内存已达10GB甚至12GB，超过了很多电脑的内存，但是很多时候仍然卡顿，一个重要的原因是软件优化不够好（很多程序设计者在面对大内存时，以不将内存优化作为程序设计的重点，于是出现了你有多少硬件资源，我软件就要占用多少硬件资源），占用了大量的硬件资源。
综上，硬件和软件是计算机重要组成部分，缺一不可。计算机性能的提升即依赖于硬件配置的提高，也依赖于软件水平的优化。
参考资料：
 https://www.sophia.org/tutorials/the-relationship-between-hardware-and-software https://www.quora.com/What-is-the-relation-between-hardware-and-software-2  2. 常见的 Linux 发行版本有哪些？它们的主要差别在什么地方？ Linux 发行版本是基于Linux内核和软件包管理系统创建的操作系统。通常一个 Linux 发行版包括 Linux 内核、GNU 工具和库、其他一些软件以及窗口系统、窗口管理器和桌面环境。 迄今为止，已经有超过 600 多个 Linux 发行版本，其中将近 500 个仍处于活跃开发状态。其中最常用的一些商业支持发行版有：Fedora(Red Hat), openSUSE(SUSE) 和 Ubuntu，社区驱动的发行版有：Debian, Slackware, Gentoo和 Arch Linux。 值得一提的是 Android 系统，我们知道 Android 也是基于 Linux 的，但是它算不算一个 Linux 发行版本呢？很多大佬有不同的意见，有人认为 Android 也是一种发行版，有人指出 Android 缺少包括 glibc 在内的很多 GUN 工具，因而不能算是一种 Linux 发行版。
Linux 发行版 = Linux 内核 + 商业软件
常见的 Linux 发行版：
 国外：RedHat、Fedora、Centos、SUSE、Debian、Ubuntu、Mint、Arch、Manjaro 国内：红旗、Deepin  是不是一千个用户就有一千个 Linux 系统推荐理由？</description>
    </item>
    
    <item>
      <title>正常人学编程 前言</title>
      <link>https://sanbeichahegongheguo.github.io/1%E6%AD%A3%E5%B8%B8%E4%BA%BA%E5%AD%A6%E7%BC%96%E7%A8%8B-%E5%89%8D%E8%A8%80/</link>
      <pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/1%E6%AD%A3%E5%B8%B8%E4%BA%BA%E5%AD%A6%E7%BC%96%E7%A8%8B-%E5%89%8D%E8%A8%80/</guid>
      <description>现有的编程课程，书本，教程，对非计算机专业、转行的初学者而言，都非常糟糕。
 抽象得太抽象浓缩，看完无法迁移。伪代码无法实现转化为实际代码。 具体的手册太具体，一大堆功能、函数、方法交给你。为了教会你，用的都是彼此分离不同属没有关联的例子。只是为了讲这个方法的用法而用，实际使用的时候依然用不好。只有正确的用法，不指出常见的错误方法。典型的就是 Python 著名的库 Pandas 的作者写的《Python数据分析》、《鸟叔的Linux私房菜》。很多编程入门书，真的就只是入门书。对于有计算机编程基础的人员，入了门，很快就可以开始做项目。但是对于从零开始的人员，则需要经过痛苦的摸索阶段。 另外一些书则是介绍一些奇淫巧技，对于初学者毫无帮助。 还有的书因为出版的缘故，写得极其精简简略，生怕多重复强调一点。实际上，就像复习是最好的学习，而不断的重复也是让初学者更好入门的招数。不要怕啰嗦，只要能把道理讲清楚，特别是对于网络发布的情况。反而应该反对过度的凝练。传统的教育方法是书本凝练，课堂详细展开。但是对于自学、转行的人员，无法达到这样的条件。 还有就是对于零基础的人员，缺乏足够的知识组合。其实学习本身应该是融会贯通的，就像在学校，不会一学期就学这一门，学完这门才学另一门，都是同步进行。而如果课程设置合理，完全可以刚在这门课学到的知识，就用在了下一门的基础上。形成良好的闭环和循环增强，巩固了旧知识，学会了新知识。 刷LeetCode怎么刷？这块其实也是一个痛点。我最开始刷LeetCode的时候，想得最多的就是，我写的这个解法，它是怎么在后台被测试的？如何更好的构建类？而一直没有一个合格的人告诉我是如何运作的，似乎所有的人都默认为大家都知道了。QTMD。 也就是说，目前存在一个 huge 的 gap 横亘在初入门和熟练资深者之间，导致初学者长期卡在初学者阶段，无法良好的进入下一阶层。这个问题需要改变。这也是我们目前现代化教育的弊端：  学生学不会。 学生学会了不会用。 学生用了但是不是应该的用法。   我们的教育也是出大问题了。
现在市面上有不少号称针对初学者的教程，比如：《一百天学会python》《零基础入门Linux》，但实际上一点都不实用。要么是太简略，该教的必备知识没教，要么是太简陋，只不过是把官方文档堆了出来，要么就是太庞杂，一坨东西呼人脸上，无所适从。
所以我想，自己试着一点点，把基础知识和引用知识，捣碎了，结合具体事例，反复灌输，传授出来。
太基础的我也不讲，因为网上已经有很多很好的。
我的大纲设计是：
 这个知识点，到底是什么，是来解决什么问题的。 这个知识点，在python下是怎么做，在Perl、Java、kotlin、Go、C/C++ 下又分别是怎么做。 配合实例，怎么把这个知识用起来。  希望能够成功。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>section01-环境配置-01</title>
      <link>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-01/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-01/</guid>
      <description>环境配置分两种，一种是语言本身的环境配置，一种是编写代码时所需要的编辑器。
1 先讲讲我们要讲的语言。 在这之前再讲语言的类型。
1.1 语言分机器语言，汇编语言，和高级语言。 机器语言，也即低级语言，就是CPU能够认识的语言，也就是二进制指令。如果让你写一段程序计算1+1，那就需要些大量的 1和0，显然正常人都没办法做到。这块以后如果有兴趣可以讲讲普通人如何用二进制编程，其实是挺有意思。类似摩尔电码一样，用1和0代表一系列运算。具象化的那就是《三体》里的人列计算机，仅仅通过1和0，构建出与门或门非门与非门等等，再在这个基础上进行逻辑运算。和目前的深度学习理念非常像。如果以后我会讲到深度学习，那就会先讲这个。
先列几个机器语言：
指令部份的示例: 0000 代表 加载（LOAD） 0001 代表 存储（STORE） ... 暂存器部份的示例: 0000 代表暂存器 A 0001 代表暂存器 B ... 存储器部份的示例: 000000000000 代表地址为 0 的存储器 000000000001 代表地址为 1 的存储器 000000010000 代表地址为 16 的存储器 100000000000 代表地址为 2^11 的存储器 集成示例: 0000,0000,000000010000 代表 LOAD A, 16 0000,0001,000000000001 代表 LOAD B, 1 0001,0001,000000010000 代表 STORE B, 16 0001,0001,000000000001 代表 STORE B, 1 ...  是不是基本上就不是给人看的。
低级语言，也称符号语言，就是在机器语言上改造出来的至少可以让人一眼看懂的语言，就是把操作性的指令，从0和1改造成约定俗成的英文字符，而且一般都是有英文原意的英文单词或缩写。比如把寄存器BX的内容送到AX中，用机器语言和汇编语言写就分别是：
1000100111011000 机器指令 mov ax,bx 汇编指令  区别还是挺明显。后者至少大概知道是啥意思。</description>
    </item>
    
    <item>
      <title>section01-环境配置-02-语言环境</title>
      <link>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-02/</link>
      <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-02/</guid>
      <description>1、优先推荐初学者先使用网上环境，而不是本地部署。 1、Cloud Studio Cloud Studio 是基于浏览器的集成式开发环境，是腾讯公司的，支持绝大部分编程语言，包括 HTML5、PHP、Python、Java、Ruby、C/C++、.NET 等等，无需下载安装程序，一键切换开发环境。 Cloud Studio 提供了完整的 Linux 环境，并且支持自定义域名指向，动态计算资源调整，可以完成各种应用的开发编译与部署。
2、实验楼 实验楼也提供网络在线的开发环境，不过非付费用户没办法保存。但是对于初入Linux的朋友，可以在上面尝试性操作，也算一个便利。
3、Google家的在线平台 这个需要翻墙，仅供参考。
2、本地编辑器 最开始入门，各类语言首先要学会如何在终端下运行，因为以后如果真的到了工业应用级别，服务器都是只提供命令行模式的。所以终端下命令，以及vim或者Emrac的使用最好能会一些。
然后就是在一些文本编辑器下使用。常见的有sublime text2or3、nodepad++、Atom、Visual Studio Code等等。
这类文本编辑器的特点就是轻量级,，不直接提供编程环境，可以自行改造成适应不同语言的编程环境。我自己使用过多款后最后选用的还是sublime text3。最够快捷和轻量级，没有VScode、Atom那么花哨。不过后两者也是很出色的，只是对于目前的我有些花哨了。
最后就是终极的IDE，集成开发环境。就是把它一装，你需要的编辑器+语言环境，都安排好了。这里的典型就是微软家的visual studio和苹果家的Xcode。装了这两个，基本上就等于装了编辑器+C/C++语言环境，如果再想装什么语言，通过内置的环境配置也可以搞定。另外还有一些语言专属的IDE。我们下面一个一个说。
首先是命令行下运行语言，这块后面肯定会一一讲到。
然后讲一下我接触到的各类文本编辑器的优劣。
首先肯定是vim和emrac。这两款文本编辑器是适用于终端界面环境下。早期编程没有图形界面，那时候的程序员写代码很麻烦的。于是就有两个程序员分别开发了各自认为合适的文本编辑器。
vi
vim是在vi基础上的增强版，Linux系统下已经默认输入vi就等于vim。所以我也没用过原版vi。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>section02-计算机起源与组成</title>
      <link>https://sanbeichahegongheguo.github.io/section02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</link>
      <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</guid>
      <description>本文转自[零基础编程入门（02）——计算机起源与组成]
附该作者的版权说明
 三、关于本教程版权 本教程系列没有出版计划，以后也不会有，内容将直接公布在网上，但严禁第三方将其修订商业使用，转载不用向我询问，但必须在头部或尾部标明鄙人的知乎原文地址，鄙人并不希望有人借本教程牟利，知识永远都不应当收费，当然如果有人看完本教程觉得很有帮助自愿想给我午餐加个鸡腿，我也不反对，先行谢了。
 作者：HalfmanG2
链接：https://zhuanlan.zhihu.com/p/36534718
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
一、计算机的起源与历史 说到计算机的起源，首先从字面上就可以了解到计算机就是用于计算的机器的意思，事实上最早的计算机也的确就是一台用于计算的机器，早在史前社会，人类就已经发明了计算机，它是长这样的：
图1，上古人力二则运算计算机
同学们看了肯定很惊诧，哎哟我去，这不就是几根破绳子嘛，和能操红警打星际（嗯，没暴露年龄吧？）的计算机有什么关系，你不是在忽悠我吧？
那鄙人得说，就这几根破绳子还真是一台计算机，原始人使用这种称为结绳记事的方式来记录日常生活中的一些数据，比如，鄙人今天下海捞了3条鱼，那么我就在一根绳子上打3个结，记住我捞了3条鱼，然后我吃了一条，就解开一个结变成2个结，如果到了月底发现框里的鱼和绳子上的结对不上，那鱼肯定就是被我老婆偷吃了，晚上回去好好教育教育&amp;hellip;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
从这个故事种我们可以看到，这几根破绳子有如下几个作用：
 可以用于记录数字，1个结就代表数字1，2个结就代表数字2，以此类推 可以进行加减运算，比如我绳子上有2个结，然后今天又捞了3条，那么就再打3个结，变成了5个结，那么就是2+3=5。然后晚上我吃了1条，于是就解开1个结，变成4个结，那么就是5-1=4。  有了这两个个作用，我们就得到了一台完整二则运算计算机，因为一台计算机只需要有两个功能：
 记录数据，将需要参与运算的数字记录下来 对数据进行运算，对记录下来的数字进行运算  但是由于只能用于加减运算，所以就称为二则运算计算机。
但是显然，这种计算机运行效率那是相当的低下，记录的数据也非常有限，比如我昨天捞了200条鱼，那我就得打200个结，绳子是不是够长不说，就是打结的功夫也是相当的累人，指不定比捞鱼还慢，而且还只能做加减运算，比如如果我和隔壁张三做大额鱼类期货交易，要做乘除法怎么办？200条鱼的绳子乘个2就是400条，那我得再打上200个结，乘个10就是2000个结，我去，这活没法干了。
所以，讲到这里鄙人不得不佩服我们古人的智慧，公元3世纪（200多年）的时候，东汉人徐岳发明了这玩意儿：
图2，国产人力四则运算计算机
没错，就是算盘，不过很可惜，由于鄙人小学珠算没及格，这东西咋用的我早丢给爷爷辈了，但是！鄙人可以告诉你，算盘相对于绳子，有两大改良：
 算盘加入了进位  我们可以看到算这个盘每一列有上面2个珠子和下面5个珠子，下面5个珠子每向上推1个代表加个1，而上面的珠子每推1个代表加5，上面2个珠子都推了就代表加10，这就是个典型的10进位，但是由于算盘有很多种，有些是上面1珠下面4珠的，所以并不能说所有算盘都是10进位，事实上更多的是混合进位，恩，说远了，不懂没关系。
当然，你现在还不知道什么是进位，鄙人后面会再给大家详细解释，不明白的同学稍安勿躁，接着看下去。
 算盘加入了乘除法  算盘可以通过一定的口诀，实现乘除法，所谓口诀就是一些预先设计好的操作顺序。比如第1步推这个，第2步推哪个等等，然后操作人员只需要根据口诀去一步步操作，就能对算盘上当前的数据进行乘除法。
当然，真正的珠算口诀要复杂的多，具体我就不说了，因为我自己也搞不清，没做过账房先生。看到这想知道的同学鄙人也不推荐你去研究，因为和我们要学的东西无关，无关的东西就不要学，这是学习的根本方法之一，有的时候我们需要克制下自己的求知欲。
回到正题，从上面我们知道，算盘可以通过这些预先设计好的操作顺序对算盘上记录的数据进行乘除法，非常有意思的是，这些口诀，从本质上来讲，就是一种程序，因为程序本质上就是进行某种运算的操作顺序，而设计了这些口诀的古人则正是我们中国最早的程序员。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
看到这里，我们同学是不是很震撼，感到特别震惊？所以说我们古中华文明的智慧是无穷无尽的，我们现代生活中的很多东西早就已经存在于中国古代，所以同学们切勿自怨自艾，国人当对身为中华人有信心，为身为中华文明的传人而自豪。同时也要为我们将要学习的内容放松心态，古人都能发明的东西，你怎么会有学不会的道理？
上面我们学到了中华文明的璀璨之后，接下来，我们把时间向后拨上1600多年，来到近现代的欧洲。
1941年，二战正进行得如火如荼，德军依靠优势空军力量，不断对英国进行空袭，大量的城镇在一夜间满目疮痍。英军为了获得对德国空军的战术与情报优势，瞄上了德国了的用于电报加密的恩尼格玛密码机（Enigma Machine）。
恩尼格玛密码机大致上就是好几个转盘，当发报员通过旋钮对机器进行日期设置后，每敲入一个字符，比如A，然后转盘就会通过一定的机械运动，将其转换为另一个字符，比如R，然后运转规律会按日期有所变化，比如今天按A，输出的是R，明天按A，输出就变成C了。然后收报员在收到加密的电报后，输入相同的日期，然后就能解密，然后得到正确的电报内容。当然实际的加密过程要复杂的多，因为还有变码等等功能，这个我们就不关心了，你就先这么理解吧。
通过这个机器，德军能很好的防止英军截获军事情报，所以，英军为了破解恩尼格玛密码机，便从全国征招各路英豪，齐聚一个叫布莱切利的小庄园，其中就有我们的人工智能之父，提出了图灵机的阿伦·图灵，还有全国的顶尖数学家和顶尖电器工程师。
然后某一天，由于一个德国发报员的发送的报文有一个拼写错误，抱着严谨的心态没换密码又重发了一遍正确的报文，英军意外通过对两份密文对比找到了恩尼格玛的部分规律，然后在天才们的努力下，最终完整破译了密码机的运行规律。
但是，我们故事到这里还没有完，虽然已经找到了密码机的运行规律，但是由于每破译一份电报都要进行巨量的数学计算，即使有一群数学大咖协作，每一份电报破译完几乎已经是一个星期后的事情了，对瞬息万变的战局几乎起不到任何作用。
于是在阿伦·图灵的主导下，电器工程师赫斯·罗宾逊与汤米·佛洛亚斯发明建造了一台电器设备，名为克罗索斯，差不多长这样：
图3，克罗索斯电器计算机
这台设备由电力马达驱动，其中用于记录密文运算的电路模块是可以替换的，以实现变换解密算法，当操作员通过打字机完成需要需要计算的电报密文输入后，这台设备便会开始根据记录了算法的电路模块对电报进行解密，每秒大约能解密5000字。
这样的运行效率显然已经完全满足了英军需要，一份德军密电几分钟后就能放到丘吉尔桌上，而克罗索斯则因为汤米·佛洛亚斯设计的独特的可替换算法电路模块，而成为了世界上第一台可编程电子计算机。
然而非常可惜的是，由于英军出于机密的考虑（恩尼格玛破译有很多黑历史就不说了，比如故意放任已经破译的密电，而让多佛惨遭轰炸），克罗索斯长期被列为高级机密，隐藏在了机密文档之中，而其计算机本身也在二战后惨遭销毁。
至于阿伦·图灵更是在二战后因其他原因被迫自杀，成为计算机界知名的惨案，至此，这段历史也就再也无人知晓，直到近十几年才得以曝光。但是此时，世界第一台电子计算机的桂冠却早已被美国1946年制造的用于原子弹制造研究计算的ENIAC埃尼阿克计算机摘去，而他的设计者之一，冯·诺依曼更是依靠其对ENIAC埃尼阿克计算机设计方案的优化，一举成为现代计算机之父。
（后注，克罗索斯破解的实质上是德军在恩尼格玛上衍生的更为复杂的Tunny密码机，但限于篇幅就混为一谈吧，事实上这也是需要克罗索斯需要能替换算法的主要原因）
二、现代计算机起源 1944年，美籍匈牙利数学家与量子物理学家，冯·诺依曼正在美国洛·斯阿拉莫斯实验室参与一件苦逼的工作，原子弹研发。由于原子弹研发过程中大量需要进行几十亿次的巨量的数学运算，他不得不雇佣了上百个妹子为其做算术题，然而依然完全不够，无尽的数学题如同海绵一般吸干了他那无穷无尽的脑细胞。
一个偶然的机会，他遇到了ENIAC埃尼阿克计算机研发部门的主管，在了解了其工作后，立刻产生了极大的兴趣，然后在主管推荐下，便以顾问的身份加入了ENIAC部门。
当时的埃尼阿克ENIAC计算机设计方案中并没有数据存储功能，其操作方式极为原始，需要由妹子（不对，操作人员）通过电线插座面板（简称控制面板，是不是很熟悉）去进行输入操作，然后再进行计算和输出结果，其输入数据操作时间往往比计算时间还长，加起来的运算效率可能还不如我们的算盘。
冯·诺依曼加入顾问团后，便开始着手对其工作方式进行改良，最终在1945年，写了一份101页的报告，提出了一个名为『EDVAC』翻译过来就是『存储程序通用电子计算机方案』的新型可编程电子计算机方案，而这个方案正是如今世界上所有计算机的根基，70年了，依然未被推翻，所以如今所有的计算机也被称为冯·诺依曼计算机，而其本人也被称为现代计算机之父而享誉全球。
在这份报告中，有三个关键点：
第一、计算机中的数据应当使用二进制进行存储与运算
第二、程序也是数据，应当与数据一同存储在计算机的存储器中
第三、计算机应当由五个部分组成，分别为：运算器、控制器、存储器、输入设备、输出设备
这三点非常重要，下面我们就一个一个来看。
第一点，计算机中的数据应当使用二进制进行存储与运算</description>
    </item>
    
    <item>
      <title>section01-环境配置-03-编辑器设置</title>
      <link>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-03/</link>
      <pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/section01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-03/</guid>
      <description>shebang
第一行代码#!/usr/bin/python3 的理解：
分成两种情况：
（1）如果调用python脚本时，使用:
python script.py  #!/usr/bin/python 被忽略，等同于注释。
（2）如果调用python脚本时，使用:
./script.py  #!/usr/bin/python 指定解释器的路径。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>聊个博士险</title>
      <link>https://sanbeichahegongheguo.github.io/%E8%81%8A%E4%B8%AA%E5%8D%9A%E5%A3%AB%E9%99%A9/</link>
      <pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/%E8%81%8A%E4%B8%AA%E5%8D%9A%E5%A3%AB%E9%99%A9/</guid>
      <description>借着一个假设的险种，讲讲保险的建模。
一 前言 现在读博士的人越来越多，但是我们也知道读博士是一个高风险的行为，中间可能存在种种问题，比如抑郁，抑郁到退学，抑郁到自杀，或者延期毕业，或者毕不了业退学的，所以有必要推出一款博士险，对冲意外风险的。
这里，我们就知道了保险的本质，是为了对冲风险，不至于意外发生的时候自己颗粒无收，起码留个青山以后有柴烧。
二 基本概念 博士险针对的是因为种种原因没有按时拿到博士学位的情况。
所以分以下4种情况：
 种种原因主动退学未拿到博士学位
 种种原因被动劝退未拿到博士学位
 种种原因意外或自杀不在世未拿到博士学位
 种种原因延期毕业拿到学位
  再加上
 按时拿到博士学位  一共5种情况。
其中，本险种针对的人群是拿到博士生，至少是拿到研究生入学通知书的。各类证明均需要
三 险种设计 四 市场规模 五 收费模型 &amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>追求卓越与A股估值虚高</title>
      <link>https://sanbeichahegongheguo.github.io/%E5%88%98%E7%BF%94%E5%92%8C%E6%88%91%E7%9A%84%E6%95%85%E4%BA%8B%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/%E5%88%98%E7%BF%94%E5%92%8C%E6%88%91%E7%9A%84%E6%95%85%E4%BA%8B%E6%A8%A1%E5%9E%8B/</guid>
      <description>为了说明一些道理，我们建立了一个刘翔和我的模型。
假设刘翔在训练的时候一直只是跟我比赛110米跨栏。
我绝对相信他永远能赢过我。但是，他肯定也赢不了奥运会奖牌了。因为他只需要不太努力就可以一直保持第一，就不会发挥出自己最大的潜能。
马拉松比赛里经常有“兔子”的说法，就是组织方会在比赛一开始的时候安排几个跑得还可以的人保持较高的速度领跑，用来激发优秀选手的潜力。“兔子”可能会在中途退出，或者降慢速度后跑完全程。不过历史上也有“兔子”发挥太出色拿了冠军的。
还有典型的就是，小城镇的学霸到了大城市的学校里，可能会被虐的死去活来。
这里就是涉及到，是做鸡头还是凤尾的故事。
如果你的鸡头可以永远做下去，那无妨在小城市做一个学霸。
以前的时代或许可以，但是现在变化如此快速剧烈的时代，已经是想做鸡头而不得了。这也是资本主义制度下对人的异化。
所以只可能选择从凤尾往前跑，没办法稳稳当当一直做鸡头了。这也是城市人经常焦虑的原因之一。
同时，这也说明了一个事情，小城镇的学霸在小城镇的时候，成绩其实是虚高的。
就像刘翔一直和我比赛，他每次都能跑第一，但是这里的第一，和奥运会、世锦赛上的第一，完全是两个东西。
我高中的时候考生考试是按照成绩分考场，第一考场的学生肯定都是优秀的学生。我头两年都是在四五考场，第三年去的第一考场。一个明显的变化是，我的语文作文成绩提高了。当时我还诧异。后来同桌提醒，其实是老师懒得批阅，普遍给第一考场的学生高分。所以我的语文作文分数也被高估，虚高的。
与之类似的就是我们的大A股。
因为我们国家对老百姓的资金转移管控很严格，每个人每年只有5万美元的兑换额度，基本上有点钱的普通人，也投资不了国外资产，那就要么卖房，要么去炒A股。所以就导致我们的房价和股价，都是虚高的。
A股的价值被高估基本上是共识。可以说90%以上的股票都是垃圾股。中国的会计，特别是上市公司的会计，第一要会的，基本上就是如何做账。想让它漂亮就漂亮，想让它垃圾就垃圾，通过人为控制低估和高估，来收割韭菜。
这就是刘翔和我的故事模型给大家的启示：
 你现在牛逼不一定代表你真的牛逼。没有经过完整市场的考验，无法做出这个判断。 现在已经是一个想做鸡头而不得的时代。想要真的过上好日子，只能选择追求卓越，而且是持续不断地追求卓越。而且还要让自己一直身处在优秀的圈子里。取法其上仅得其中，取法其中仅得其下。暂时的满足感优越感只会毁了未来的你。 当然，偶尔也得劳逸结合。刘翔训练110米跨栏的时候也不是天天跑110米跨栏，他平时更多的训练是拉伸、负重、爆发力等。 对A股保持足够的谨慎、警惕和距离。  &amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://sanbeichahegongheguo.github.io/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/about/</guid>
      <description>我的个人小站。记录学习和一些感悟。
希望你会喜欢这里。
&amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>Git入门</title>
      <link>https://sanbeichahegongheguo.github.io/git%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 30 Dec 2000 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/git%E5%85%A5%E9%97%A8/</guid>
      <description>一、Git是什么 1、
2、
二、Git基本用法 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。
下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。
  Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库   一、新建代码库 git init # 在当前目录新建一个Git代码库 git init [project-name] # 新建一个目录，将其初始化为Git代码库 git clone [url] # 下载一个项目和它的整个代码历史  二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。
git config --list # 显示当前的Git配置 git config -e [--global] # 编辑Git配置文件 git config [--global] user.name &amp;quot;[name]&amp;quot; # 设置提交代码时的用户信息 git config [--global] user.email &amp;quot;[email address]&amp;quot; # 设置提交代码时的用户信息  三、增加/删除文件 git add [file1] [file2] ... # 添加指定文件到暂存区 git add [dir] # 添加指定目录到暂存区，包括子目录 git add .</description>
    </item>
    
    <item>
      <title>Git常见问题总结</title>
      <link>https://sanbeichahegongheguo.github.io/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 30 Dec 2000 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>The file will have its original line endings in your working directory 出现这个问题主要原因是：我们从别人github地址上通过git clone下载下来，而又想git push到我们自己的github上，那么就会出现上面提示的错误信息
此时需要执行如下代码：
git rm -r --cached . git config core.autocrlf false git add .  . 代表当前目录
Git 的 config 的三级配置 2.1 最高级：git config --system 信息保存在 /etc/gitconfig
为系统设置配置。
2.2 第二级：git config --global 信息保存在 ~/.gitconfig 或 ~/.config/git/config
只针对当前用户。
2.3 第三级：git congfig --local 信息保存在当前仓库的Git目录中的 .git/config
只针对该仓库。
每一个级别覆盖上一级别的配置。
Git传输协议 和 HTTPS 传输协议 两者有不同。
让git status 显示中文，解决中文乱码 本文转载自：git status 显示中文和解决中文乱码</description>
    </item>
    
    <item>
      <title>NASA 照片示例</title>
      <link>https://sanbeichahegongheguo.github.io/nasa-images/</link>
      <pubDate>Wed, 27 Dec 2000 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/nasa-images/</guid>
      <description>The below images are from the NASA Image and Video Library &amp;ndash; indulge yourself, revel in their beauty.
The Sun is the star at the center of the Solar System. It is a nearly perfect sphere of hot plasma, with internal convective motion that generates a magnetic field via a dynamo process. It is by far the most important source of energy for life on Earth. Credits.The Moon is an astronomical body that orbits planet Earth and is Earth&amp;rsquo;s only permanent natural satellite.</description>
    </item>
    
    <item>
      <title>GitHub使用入门及问题汇集</title>
      <link>https://sanbeichahegongheguo.github.io/github%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 28 Mar 2000 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/github%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>作者：荒野雄兵 来源：CSDN 原文：https://blog.csdn.net/daerzei/article/details/79528153 版权声明：本文为博主原创文章，转载请附上博文链接！
Push failed: Failed with error: unable to access &#39;https://github.com/********&#39;: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443  &amp;mdash; EOF &amp;mdash;
*EOF*是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取。通常在文本的最后存在此字符表示资料结束。
本人公众号[火山灰]，[time_ash_past]</description>
    </item>
    
    <item>
      <title>Katex Math Typesetting</title>
      <link>https://sanbeichahegongheguo.github.io/katex-math-typesetting/</link>
      <pubDate>Tue, 28 Mar 2000 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/katex-math-typesetting/</guid>
      <description>Enable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.
Note: Use the online reference of supported TeX functions.
Some math:
$$ \varphi = \dfrac{1+\sqrt5}{2}= 1.6180339887… $$  $$ \varphi = \dfrac{1+\sqrt5}{2}= 1.6180339887… $$
More math:
$$ \varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } } $$  $$ \varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } } $$
&amp;mdash; EOF &amp;mdash;</description>
    </item>
    
    <item>
      <title>Cupper主题提供的小代码</title>
      <link>https://sanbeichahegongheguo.github.io/cupper-shortcodes/</link>
      <pubDate>Sat, 12 Feb 2000 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/cupper-shortcodes/</guid>
      <description>blockquote {{% blockquote author=&amp;quot;Carl Jung&amp;quot; %}} Even a happy life cannot be without a measure of darkness, and the word happy would lose its meaning if it were not balanced by sadness. It is far better to take things as they come along with patience and equanimity. {{% /blockquote %}}  Even a happy life cannot be without a measure of darkness, and the word happy would lose its meaning if it were not balanced by sadness.</description>
    </item>
    
    <item>
      <title>vim入门</title>
      <link>https://sanbeichahegongheguo.github.io/vim%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 31 Dec 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/vim%E5%85%A5%E9%97%A8/</guid>
      <description>一、vi介绍 二、vim介绍 1、基本介绍 先摘录一下官网：
Copyright &amp;copy; 2007 Laurent Gregoire
 Vim is a highly configurable text editor for efficiently creating and changing any kind of text. It is included as &amp;ldquo;vi&amp;rdquo; ith most UNIX systems and with Apple OS X.
Vim is often called a &amp;ldquo;programmer&amp;rsquo;s editor,&amp;rdquo; and so useful for programming that many consider it an entire IDE. It&amp;rsquo;s not just for programmers, though. Vim is perfect for all kinds of text editing, from composing email to editing configuration files.</description>
    </item>
    
    <item>
      <title>Anaconda入门</title>
      <link>https://sanbeichahegongheguo.github.io/anaconda%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/anaconda%E5%85%A5%E9%97%A8/</guid>
      <description>一、Anaconda介绍 Anaconda是一个Python的科学计算发行版，包含了超过300个流行的用于科学、数学、工程和数据分析的Python Packages。由于Python有2和3两个版本，因此Anaconda也在Python2和Python3的基础上推出了两个发行版，即Anaconda2和Anaconda3。
二、Anaconda版本 三、同时安装Anaconda2\3 1.Windows下同时安装Anaconda2和Anaconda3 1.1前言 有时候我们会在电脑上同时使用Anaconda2和Anaconda3两个版本，因此有必要考虑它们的共存问题。一般的使用场景是以其中一个版本为主，另外一个版本为辅，因此只需要达到能方便的切换到备用版本，且备用版本的pip等命令能正常使用即可。
由于Anaconda2和Anaconda3包含较多的模块，很多人是不需要这些的，因此若只想要较为纯净的Python2和Python3共存的，可以看本文最后一部分。
1.2操作步骤  首先安装主版本，在这里我们选择Anaconda2，按照正常步骤安装即可，这里假定安装目录为D:\Anaconda2。   在这一步打上那两个勾。  第一个选项是将安装目录加入到系统的PATH环境变量中，以后在CMD中便可以直接用python命令启动python。 第二个选项是让其他IDE能够检测到Anaconda2并将Anaconda2作为默认的Python 2.7。
 安装好Anaconda2之后，再安装Anaconda3，这里Anaconda3的安装目录必须选在D:\Anaconda2\envs子目录下，如图所示，最后的”py3”可以自己另取。   这里取消掉那两个勾（按照字面意思理解，打上第二个勾应该是没有影响的。至于第一个选项，由于之前已经把Anaconda2添加到系统PATH路径下了，因此再把Anaconda3添加进去，由于顺序在Anaconda2的后面，几乎是没有作用的，所以这里没有勾上）。   安装完成之后，在CMD里面直接输入python会启动Python2，而使用activate py3（py3即之前Python3安装目录文件夹的名字）命令之后，再使用python即可切换至Python3，如下图所示。使用activate py3命令之后，在命令行前面会出现一个[py3]标记，此时使用任何的python命令都是在Python3下进行的。使用deactivate命令可取消激活Python3。  1.3纯净Python共存 说是纯净，其实也不完全“纯净”，这里需要用到另外一个发行版miniconda，它仅包含Python本身和Conda包管理器，因此体积不大。使用miniconda时的共存安装方法与上述步骤完全一致，就不赘述了。
miniconda下载主页
1.4总结 本文的共存实现方法其实是基于conda的创建虚拟环境的功能，详情可见此链接。
因此在首先安装主要版本之后，也可使用conda create -n py3 python=3命令来安装Python3，但由于网络问题，这种方法容易失败，所以自己先下载好完整安装包，然后安装到主版本主目录下的envs文件夹更方便。
有人也许会说直接同时安装Anaconda2和Anaconda3，然后将Anaconda3目录下的python.exe改为python3.exe也可实现类似的共存。但这种方法存在一个较大的缺陷，即Anaconda3内包含的某些IDE会工作不正常，如Jupyter Notebook和Spyder等，因为他们依赖于安装目录下的python.exe，且备用版本的pip等命令也没办法直接使用，总体来说很不方便。
很多的情况下使用python3的资源会比2多不少，比如说在xgboost包的安装问题上，python2需要用到GIT，编译器等，先下载源码再编译，然后添加路径，之后通过GIT调用python安装，还不一定成功。反观python3，网上有现成的.whl文件，下载下来pip一下就好，轻松又愉快。但是对于之前用惯了python2，并且有不少代码已经写在里边的同学，一时间要换成3也是有点困难，所以就需要同时使用python2和3了。我们需要的是基于某个版本的anaconda，2或者3都可以，下面以2为例。
首先需要我们设置一下anaconda，使用清华的镜像，原地址会非常慢。cmd中输入
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes  这之后在你的c:\Users\用户名下的.condarc中就会多了我们添加的地址
只需要删掉defaults那一行，保存一下就设置成功了。
之后开始干正事，首先在cmd中写入命令
conda update conda  用于更新anaconda，完成后
conda create --name python3 python=3.6 activate python3  相当于在conda目录的envs文件夹中创建了一个新的环境python3，并且通过activate命令激活了它，在activate命令后你的cmd前应该多了一个括号里面写着python3</description>
    </item>
    
    <item>
      <title>Zotero入门</title>
      <link>https://sanbeichahegongheguo.github.io/zotero%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/zotero%E5%85%A5%E9%97%A8/</guid>
      <description>注：本文在阳博客基础上修改增加内容。
注册Zotero新账号并下载 登陆https://www.zotero.org/user/register/，注册一个自己的Zotero账号，请特别记住，username会直接生成个性域名，别乱起，未来会有些不方便。
下载Zotero单机版，也就是Zotero Standalone。Mac、Windows等通用。
http://www.zotero.org/download/
也可以下载firefox插件版，但是我更推荐单机版。两者的区别如下：
下载之后安装默认提示一路安装。
Zotero版本介绍 Zotero有桌面版和浏览器版。
配置Zotero 打开Zotero，找到[首选项]或偏好：
在同步一栏输入前面注册的账号，这样，文献库可以同步到[Zotero]官网。官方给我们提供了100MB的共享同步空间。当然基本不够用，后面会介绍如果用坚果云扩展。
创建一个用来保存文献库的根目录，假设是：/users/ouyang/dev/zotero 继续配置：
[Zotero]官网默认的存储空间有限，所以，我们需要一个小技巧，将文献库里面保存PDF文档的目录，分离开，放到[dropbox]目录下同步。回到刚才创建的：/users/ouyang/dev/zotero 目录，其中的storage目录是拿来保存PDF等文档的，将其剪切到[dropbox]目录下，如下图所示：
打开终端或shell，创建一个软连接，让[Zotero]认出该目录：
ln -s /users/ouyang/dropbox/zotero/storage /users/ouyang/dev/zotero/storage  回头看，/users/ouyang/dev/zotero 目录下多了一个软链接，表示成功了。
接下去，在配置这里安装pdf索引：
以及，将默认输出格式，更改为APA第六版：
导入第一篇文献 好了，准备工作做完了。现在，让我们导入第一篇文献。Zotero支持以下六种导入方法：
 互联网自动识别：Web Translators (URL bar icon) 手动输入：Manual Input or Edit From a bibliographic 文件导入：format (RIS, BibTeX, MARC, etc.) 通过标示符增加：Add by identiﬁer (DOI, ISBN, PMID) 通过PDF元数据识别：Add PDF then Retrieve Metadata 从网页识别：Get any Webpage with basic data  先让我们找找成就感，从最容易的开始。通过Web Translators，互联网自动识别。
打开豆瓣网站，随便找一本书，让我们以前一篇文章[心智十二宫]中的[我生活的种种模式]为例，它的豆瓣网页是：
http://book.douban.com/subject/1065156/</description>
    </item>
    
    <item>
      <title>[转载]版本控制系统入门</title>
      <link>https://sanbeichahegongheguo.github.io/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%85%A5%E9%97%A8/</guid>
      <description>本文转载自阮一峰的博客。
我知道版本控制系统（VCS）很有用。
但是，我平时只是业余写一些小程序，感觉特地装一个VCS太麻烦，所以一直没有用。最近，因为想认真做一个中等规模的项目，所以决心好好学一下怎么用。
下面就是我翻译的一篇入门教程，主要解释了VCS的一些主要概念。
作者：Kalid Azad
译者：阮一峰
原文网址：http://betterexplained.com/articles/a-visual-guide-to-version-control/
 1. A Visual Guide to Version Control 2. 版本控制入门插图教程 - 2.0.1. 前言 - 2.0.2. 什么是版本控制系统（VCS）？ - 2.0.3. 一些术语 - 2.0.3.1. 基本概念 - 2.0.3.2. 基本操作 - 2.0.3.3. 高级操作 - 2.0.3.3.1. Check in - 2.0.3.3.2. Check out和编辑 - 2.0.3.3.3. Diff - 2.0.3.3.4. Branch - 2.0.3.3.5. Merge - 2.0.3.3.6. Conflict - 2.0.3.3.7. Tag - 2.0.3.4. 一个实际的例子：管理Windows源码 - 2.0.4. 结束语  2.0.1. 前言 版本控制（Version Control）的作用是追踪文件的变化。为什么需要版本控制？简单说，就是当你出错了，可以很容易地回到没出错时的状态。</description>
    </item>
    
    <item>
      <title>自然语言处理入门</title>
      <link>https://sanbeichahegongheguo.github.io/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sanbeichahegongheguo.github.io/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/</guid>
      <description>一、文本相似度计算 文本相似度计算在信息检索、数据挖掘、机器翻译、文档复制检测等领域有着广泛的应用。文本相似度常用的计算方法有TF-IDF、LSI、LDA等。
TF-IDF模型 TF-IDF（Term Frequency-Inverse Document Frequency）是一种统计方法，用以评估某一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。
 字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。
 TF-IDF加权的各种形式常被搜寻引擎应用，作为文件与用户查询之间相关程度的度量或评级。
在一份给定的文件里，词频 (term frequency, TF) 指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被归一化，以防止它偏向长的文件。
逆向文件频率 (inverse document frequency, IDF) 是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到。
某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。
TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。
LSI模型 LSI（Latent Semantic Indexing）又称为潜在语义分析(LSA)，是在信息检索领域提出来的一个概 念。主要用于解决一词多义（如“bank”一词，可以指银行，也可以指河岸）和一义多词（如“car”和“automobile”具有相同的含义）。依靠余弦相似性的方法并不能很好地解决上述问题，所以提出了潜在语义索引的方法，利用SVD降维的方法将词项和文本映射到一个新的空间。
LDA模型 LDA（Latent Dirichlet Allocation）是一种文档主题生成模型，也称为一个三层贝叶斯概率模型，包含词、主题和文档三层结构。所谓生成模型，就是说，我们认为一篇文章的每个词都是通过“以一定概率选择了某个主题，并从这个主题中以一定概率选择某个词语”这样一个过程得到。文档到主题服从多项式分布，主题到词服从多项式分布。
LDA是一种非监督机器学习技术，可以用来识别大规模文档集（document collection）或语料库（corpus）中潜藏的主题信息。它采用了词袋（bag of words）的方法，这种方法将每一篇文档视为一个词频向量，从而将文本信息转化为了易于建模的数字信息。但是词袋方法没有考虑词与词之间的顺序，这简化了问题的复杂性，同时也为模型的改进提供了契机。每一篇文档代表了一些主题所构成的一个概率分布，而每一个主题又代表了很多单词所构成的一个概率分布。
二、中文文本处理利器snownlp SnowNLP是一个python写的类库，可以方便的处理中文文本内容。如中文分词、词性标注、情感分析、文本分类、提取文本关键词、文本相似度计算等。
snownlp示例如下所示：
# -*- coding: utf-8 -*- &amp;quot;&amp;quot;&amp;quot; Created on Wed May 31 22:28:23 2017 @author: Administrator &amp;quot;&amp;quot;&amp;quot; from snownlp import SnowNLP s = SnowNLP(u&#39;这个东西真心很赞&#39;) s.words # [u&#39;这个&#39;, u&#39;东西&#39;, u&#39;真心&#39;, # u&#39;很&#39;, u&#39;赞&#39;] s.</description>
    </item>
    
  </channel>
</rss>